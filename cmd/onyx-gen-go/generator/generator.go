package generator

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

// Options captures configuration for the Go code generator.
type Options struct {
	SchemaPath      string
	Source          string
	DatabaseID      string
	OutPath         string // directory where generated files are written
	PackageName     string
	Tables          []string
	TimestampFormat string
}

// Run validates the provided options and performs generation.
func Run(opts Options) error {
	if err := ValidateOptions(&opts); err != nil {
		return err
	}

	schema, err := loadSchema(context.Background(), opts)
	if err != nil {
		return err
	}

	if err := os.MkdirAll(opts.OutPath, 0o755); err != nil {
		return err
	}

	modelsPath := filepath.Join(opts.OutPath, "models.go")
	clientPath := filepath.Join(opts.OutPath, "client.go")

	modelsCode := renderModels(schema, opts.PackageName, opts.TimestampFormat)
	if err := os.WriteFile(modelsPath, modelsCode, 0o644); err != nil {
		return err
	}

	clientCode := renderClient(schema, opts.PackageName)
	if err := os.WriteFile(clientPath, clientCode, 0o644); err != nil {
		return err
	}

	return nil
}

// ValidateOptions ensures the provided options meet the CLI requirements.
func ValidateOptions(opts *Options) error {
	if opts == nil {
		return fmt.Errorf("options cannot be nil")
	}

	if opts.TimestampFormat == "" {
		opts.TimestampFormat = "time"
	}

	if opts.TimestampFormat != "time" && opts.TimestampFormat != "string" {
		return fmt.Errorf("invalid --timestamps value %q (must be \"time\" or \"string\")", opts.TimestampFormat)
	}

	opts.Source = strings.ToLower(strings.TrimSpace(opts.Source))
	if opts.Source == "" {
		opts.Source = "file"
	}

	if opts.Source != "file" && opts.Source != "api" {
		return fmt.Errorf("invalid --source value %q (must be \"file\" or \"api\")", opts.Source)
	}

	if opts.OutPath == "" {
		opts.OutPath = "./onyxclient"
	}

	if opts.PackageName == "" {
		opts.PackageName = filepath.Base(opts.OutPath)
	}

	if opts.SchemaPath == "" {
		opts.SchemaPath = "./onyx.schema.json"
	}

	return nil
}

func renderModels(schema onyx.Schema, pkg, timestampFormat string) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by onyx-gen-go; DO NOT EDIT.\n\n")

	buf.WriteString("package ")
	buf.WriteString(pkg)
	buf.WriteString("\n\n")

	imports := []string{}
	if needsTime(schema, timestampFormat) {
		imports = append(imports, "time")
	}
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range imports {
			fmt.Fprintf(&buf, "\t%q\n", imp)
		}
		buf.WriteString(")\n\n")
	}

	buf.WriteString("var Tables = struct {\n")
	for _, t := range schema.Tables {
		fmt.Fprintf(&buf, "\t%s string\n", toExported(t.Name))
	}
	buf.WriteString("}{\n")
	for _, t := range schema.Tables {
		fmt.Fprintf(&buf, "\t%s: %q,\n", toExported(t.Name), t.Name)
	}
	buf.WriteString("}\n\n")

	if hasResolvers(schema) {
		buf.WriteString("var Resolvers = map[string][]string{\n")
		for _, t := range schema.Tables {
			if len(t.Resolvers) == 0 {
				continue
			}
			buf.WriteString(fmt.Sprintf("\t%q: {", t.Name))
			for i, r := range t.Resolvers {
				if i > 0 {
					buf.WriteString(", ")
				}
				buf.WriteString(fmt.Sprintf("%q", r.Name))
			}
			buf.WriteString("},\n")
		}
		buf.WriteString("}\n\n")
	}

	for _, t := range schema.Tables {
		typeName := toExported(t.Name)
		fmt.Fprintf(&buf, "type %s struct {\n", typeName)
		for _, f := range t.Fields {
			fieldName := toExported(f.Name)
			goType := mapFieldType(f, timestampFormat)
			fmt.Fprintf(&buf, "\t%s %s `json:\"%s,omitempty\"`\n", fieldName, goType, f.Name)
		}
		for _, r := range t.Resolvers {
			fieldName := toExported(r.Name)
			fmt.Fprintf(&buf, "\t%s any `json:\"%s,omitempty\"`\n", fieldName, r.Name)
		}
		buf.WriteString("}\n\n")
	}

	return buf.Bytes()
}

func renderClient(schema onyx.Schema, pkg string) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by onyx-gen-go; DO NOT EDIT.\n\n")
	buf.WriteString("package " + pkg + "\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"github.com/OnyxDevTools/onyx-database-go/onyx\"\n")
	buf.WriteString(")\n\n")

	buf.WriteString("type Client struct { core onyx.Client }\n\n")
	buf.WriteString("func NewClient(core onyx.Client) Client { return Client{core: core} }\n\n")
	buf.WriteString("func (c Client) Core() onyx.Client { return c.core }\n\n")

	for _, t := range schema.Tables {
		typeName := toExported(t.Name)
		plural := toPlural(typeName)
		resourceName := fmt.Sprintf("%sClient", plural)
		pageName := fmt.Sprintf("%sPage", typeName)
		pageMapName := fmt.Sprintf("%sMapPage", typeName)

		fmt.Fprintf(&buf, "type %s struct {\n\tItems []%s `json:\"items\"`\n\tNextCursor string `json:\"nextCursor,omitempty\"`\n}\n\n", pageName, typeName)
		fmt.Fprintf(&buf, "type %s struct {\n\tItems []map[string]any `json:\"items\"`\n\tNextCursor string `json:\"nextCursor,omitempty\"`\n}\n\n", pageMapName)
		fmt.Fprintf(&buf, "type %s struct { core onyx.Client; ctx context.Context; q onyx.Query }\n\n", resourceName)
		fmt.Fprintf(&buf, "func (c Client) %s(ctx context.Context) %s { return %s{core: c.core, ctx: ctx, q: c.core.From(Tables.%s)} }\n\n", plural, resourceName, resourceName, typeName)
		fmt.Fprintf(&buf, "func (c %s) WithContext(ctx context.Context) %s { c.ctx = ctx; return c }\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) Where(cond onyx.Condition) %s { c.q = c.q.Where(cond); return c }\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) And(cond onyx.Condition) %s { c.q = c.q.And(cond); return c }\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) Or(cond onyx.Condition) %s { c.q = c.q.Or(cond); return c }\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) Resolve(resolvers ...string) %s { c.q = c.q.Resolve(resolvers...); return c }\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) OrderBy(field string, asc bool) %s {\n\tif asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }\n\treturn c\n}\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) Limit(n int) %s { c.q = c.q.Limit(n); return c }\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) Select(fields ...string) %s { c.q = c.q.Select(fields...); return c }\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) GroupBy(fields ...string) %s { c.q = c.q.GroupBy(fields...); return c }\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) SetUpdates(updates map[string]any) %s { c.q = c.q.SetUpdates(updates); return c }\n", resourceName, resourceName)
		fmt.Fprintf(&buf, "func (c %s) Stream(ctx context.Context) (onyx.Iterator, error) { ctx = useContext(ctx, c.ctx); return c.q.Stream(ctx) }\n", resourceName)
		fmt.Fprintf(&buf, "func (c %s) List(ctx context.Context) ([]%s, error) {\n\tctx = useContext(ctx, c.ctx)\n\tres := onyx.List(ctx, c.q)\n\tvar out []%s\n\tif err := res.Decode(&out); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n", resourceName, typeName, typeName)
		fmt.Fprintf(&buf, "func (c %s) ListMaps(ctx context.Context) ([]map[string]any, error) {\n\tctx = useContext(ctx, c.ctx)\n\tres := onyx.List(ctx, c.q)\n\tvar out []map[string]any\n\tif err := res.Decode(&out); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n", resourceName)
		fmt.Fprintf(&buf, "func (c %s) ListAggregates(ctx context.Context) ([]map[string]any, error) {\n\tctx = useContext(ctx, c.ctx)\n\tres := onyx.List(ctx, c.q)\n\tvar out []map[string]any\n\tif err := res.Decode(&out); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n", resourceName)
		fmt.Fprintf(&buf, "func (c %s) Page(ctx context.Context, cursor string) (%s, error) {\n\tctx = useContext(ctx, c.ctx)\n\tres, err := c.q.Page(ctx, cursor)\n\tif err != nil {\n\t\treturn %s{}, err\n\t}\n\tvar items []%s\n\tif err := decodeList(res.Items, &items); err != nil {\n\t\treturn %s{}, err\n\t}\n\treturn %s{Items: items, NextCursor: res.NextCursor}, nil\n}\n\n", resourceName, pageName, pageName, typeName, pageName, pageName)
		fmt.Fprintf(&buf, "func (c %s) PageOfMaps(ctx context.Context, cursor string) (%s, error) {\n\tctx = useContext(ctx, c.ctx)\n\tres, err := c.q.Page(ctx, cursor)\n\tif err != nil {\n\t\treturn %s{}, err\n\t}\n\treturn %s{Items: res.Items, NextCursor: res.NextCursor}, nil\n}\n\n", resourceName, pageMapName, pageMapName, pageMapName)
		fmt.Fprintf(&buf, "func (c %s) Update(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Update(ctx) }\n\n", resourceName)
		fmt.Fprintf(&buf, "func (c %s) Delete(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Delete(ctx) }\n\n", resourceName)
		fmt.Fprintf(&buf, "func (c %s) Save(item %s, cascades ...onyx.CascadeSpec) (%s, error) {\n\tctx := useContext(nil, c.ctx)\n\trelationships := make([]string, 0, len(cascades))\n\tfor _, spec := range cascades {\n\t\tif spec != nil {\n\t\t\trelationships = append(relationships, spec.String())\n\t\t}\n\t}\n\tif len(relationships) == 0 {\n\t\trelationships = nil\n\t}\n\tsaved, err := c.core.Save(ctx, Tables.%s, item, relationships)\n\tif err != nil {\n\t\treturn %s{}, err\n\t}\n\tvar out %s\n\tif err := decodeSaved(saved, &out); err != nil {\n\t\treturn %s{}, err\n\t}\n\treturn out, nil\n}\n\n", resourceName, typeName, typeName, typeName, typeName, typeName, typeName)
		fmt.Fprintf(&buf, "func (c %s) DeleteByID(id string) error {\n\tctx := useContext(nil, c.ctx)\n\treturn c.core.Delete(ctx, Tables.%s, id)\n}\n\n", resourceName, typeName)
	}

	buf.WriteString("func decodeSaved(saved map[string]any, out any) error {\n\tb, err := json.Marshal(saved)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(b, out)\n}\n\n")
	buf.WriteString("func decodeList(items []map[string]any, out any) error {\n\tb, err := json.Marshal(items)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(b, out)\n}\n\n")
	buf.WriteString("func useContext(ctx, fallback context.Context) context.Context {\n\tif ctx != nil {\n\t\treturn ctx\n\t}\n\treturn fallback\n}\n\n")

	// Documents passthrough helpers
	buf.WriteString("type DocumentsClient struct { core onyx.DocumentClient }\n\n")
	buf.WriteString("func (c Client) Documents() DocumentsClient { return DocumentsClient{core: c.core.Documents()} }\n\n")
	buf.WriteString("func (d DocumentsClient) List(ctx context.Context) ([]onyx.Document, error) { return d.core.List(ctx) }\n")
	buf.WriteString("func (d DocumentsClient) Get(ctx context.Context, id string) (onyx.Document, error) { return d.core.Get(ctx, id) }\n")
	buf.WriteString("func (d DocumentsClient) Save(ctx context.Context, doc onyx.Document) (onyx.Document, error) { return d.core.Save(ctx, doc) }\n")
	buf.WriteString("func (d DocumentsClient) Delete(ctx context.Context, id string) error { return d.core.Delete(ctx, id) }\n\n")

	// Secrets passthrough helpers
	buf.WriteString("type SecretsClient struct { core onyx.Client }\n\n")
	buf.WriteString("func (c Client) Secrets() SecretsClient { return SecretsClient{core: c.core} }\n\n")
	buf.WriteString("func (s SecretsClient) List(ctx context.Context) ([]onyx.Secret, error) { return s.core.ListSecrets(ctx) }\n")
	buf.WriteString("func (s SecretsClient) Get(ctx context.Context, key string) (onyx.Secret, error) { return s.core.GetSecret(ctx, key) }\n")
	buf.WriteString("func (s SecretsClient) Set(ctx context.Context, secret onyx.Secret) (onyx.Secret, error) { return s.core.PutSecret(ctx, secret) }\n")
	buf.WriteString("func (s SecretsClient) Delete(ctx context.Context, key string) error { return s.core.DeleteSecret(ctx, key) }\n\n")

	return buf.Bytes()
}

func toExported(name string) string {
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsDigit(r)
	})
	var b strings.Builder
	for _, p := range parts {
		if p == "" {
			continue
		}
		r, size := utf8.DecodeRuneInString(p)
		b.WriteRune(unicode.ToUpper(r))
		b.WriteString(p[size:])
	}
	if b.Len() == 0 {
		return "Name"
	}
	return b.String()
}

func mapFieldType(f onyx.Field, timestampFormat string) string {
	kind := strings.ToLower(strings.TrimSpace(f.Type))
	switch kind {
	case "string":
		if f.Nullable {
			return "*string"
		}
		return "string"
	case "boolean", "bool":
		if f.Nullable {
			return "*bool"
		}
		return "bool"
	case "int", "integer":
		if f.Nullable {
			return "*int64"
		}
		return "int64"
	case "timestamp", "datetime", "date", "time":
		if strings.ToLower(timestampFormat) == "string" {
			if f.Nullable {
				return "*string"
			}
			return "string"
		}
		if f.Nullable {
			return "*time.Time"
		}
		return "time.Time"
	case "embeddedobject", "object", "json", "map", "any":
		return "map[string]any"
	default:
		return "any"
	}
}

func needsTime(schema onyx.Schema, timestampFormat string) bool {
	if strings.ToLower(timestampFormat) == "string" {
		return false
	}
	for _, t := range schema.Tables {
		for _, f := range t.Fields {
			kind := strings.ToLower(strings.TrimSpace(f.Type))
			if kind == "timestamp" || kind == "datetime" || kind == "date" || kind == "time" {
				return true
			}
		}
	}
	return false
}

func hasResolvers(schema onyx.Schema) bool {
	for _, t := range schema.Tables {
		if len(t.Resolvers) > 0 {
			return true
		}
	}
	return false
}

func toPlural(name string) string {
	if strings.HasSuffix(name, "s") {
		return name
	}
	return name + "s"
}

func clientOutPath(outDir string) string {
	return filepath.Join(outDir, "client.go")
}

// ClientPathFor exposes the client path calculation for external callers.
func ClientPathFor(outDir string) string {
	return clientOutPath(outDir)
}
