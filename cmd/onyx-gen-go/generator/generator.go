package generator

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/OnyxDevTools/onyx-database-go/core"
)

// Options captures configuration for the Go code generator.
type Options struct {
	SchemaPath      string
	Source          string
	DatabaseID      string
	OutPath         string // directory where generated files are written
	PackageName     string
	Tables          []string
	TimestampFormat string
}

// Run validates the provided options and performs generation.
func Run(opts Options) error {
	if err := ValidateOptions(&opts); err != nil {
		return err
	}

	schema, err := loadSchema(context.Background(), opts)
	if err != nil {
		return err
	}

	if err := os.MkdirAll(opts.OutPath, 0o755); err != nil {
		return err
	}

	modelsPath := filepath.Join(opts.OutPath, "models.go")
	clientPath := filepath.Join(opts.OutPath, "client.go")

	modelsCode := renderModels(schema, opts.PackageName, opts.TimestampFormat)
	if err := os.WriteFile(modelsPath, modelsCode, 0o644); err != nil {
		return err
	}

	clientCode := renderClient(schema, opts.PackageName)
	if err := os.WriteFile(clientPath, clientCode, 0o644); err != nil {
		return err
	}

	return nil
}

// ValidateOptions ensures the provided options meet the CLI requirements.
func ValidateOptions(opts *Options) error {
	if opts == nil {
		return fmt.Errorf("options cannot be nil")
	}

	if opts.TimestampFormat == "" {
		opts.TimestampFormat = "time"
	}

	if opts.TimestampFormat != "time" && opts.TimestampFormat != "string" {
		return fmt.Errorf("invalid --timestamps value %q (must be \"time\" or \"string\")", opts.TimestampFormat)
	}

	opts.Source = strings.ToLower(strings.TrimSpace(opts.Source))
	if opts.Source == "" {
		opts.Source = "file"
	}

	if opts.Source != "file" && opts.Source != "api" {
		return fmt.Errorf("invalid --source value %q (must be \"file\" or \"api\")", opts.Source)
	}

	if opts.OutPath == "" {
		opts.OutPath = "./onyxclient"
	}

	if opts.PackageName == "" {
		opts.PackageName = filepath.Base(opts.OutPath)
	}

	if opts.SchemaPath == "" {
		opts.SchemaPath = "./onyx.schema.json"
	}

	return nil
}

func renderModels(schema core.Schema, pkg, timestampFormat string) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by onyx-gen-go; DO NOT EDIT.\n\n")

	buf.WriteString("package ")
	buf.WriteString(pkg)
	buf.WriteString("\n\n")

	imports := []string{}
	if needsTime(schema, timestampFormat) {
		imports = append(imports, "time")
	}
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range imports {
			fmt.Fprintf(&buf, "\t%q\n", imp)
		}
		buf.WriteString(")\n\n")
	}

	buf.WriteString("var Tables = struct {\n")
	for _, t := range schema.Tables {
		fmt.Fprintf(&buf, "\t%s string\n", toExported(t.Name))
	}
	buf.WriteString("}{\n")
	for _, t := range schema.Tables {
		fmt.Fprintf(&buf, "\t%s: %q,\n", toExported(t.Name), t.Name)
	}
	buf.WriteString("}\n\n")

	if hasResolvers(schema) {
		buf.WriteString("var Resolvers = map[string][]string{\n")
		for _, t := range schema.Tables {
			if len(t.Resolvers) == 0 {
				continue
			}
			buf.WriteString(fmt.Sprintf("\t%q: {", t.Name))
			for i, r := range t.Resolvers {
				if i > 0 {
					buf.WriteString(", ")
				}
				buf.WriteString(fmt.Sprintf("%q", r.Name))
			}
			buf.WriteString("},\n")
		}
		buf.WriteString("}\n\n")
	}

	for _, t := range schema.Tables {
		typeName := toExported(t.Name)
		fmt.Fprintf(&buf, "type %s struct {\n", typeName)
		for _, f := range t.Fields {
			fieldName := toExported(f.Name)
			goType := mapFieldType(f, timestampFormat)
			fmt.Fprintf(&buf, "\t%s %s `json:\"%s,omitempty\"`\n", fieldName, goType, f.Name)
		}
		for _, r := range t.Resolvers {
			fieldName := toExported(r.Name)
			fmt.Fprintf(&buf, "\t%s any `json:\"%s,omitempty\"`\n", fieldName, r.Name)
		}
		buf.WriteString("}\n\n")
	}

	return buf.Bytes()
}

func renderClient(schema core.Schema, pkg string) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by onyx-gen-go; DO NOT EDIT.\n\n")
	buf.WriteString("package " + pkg + "\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"github.com/OnyxDevTools/onyx-database-go/core\"\n")
	buf.WriteString(")\n\n")

	buf.WriteString("type Client struct { core core.Client }\n\n")
	buf.WriteString("func NewClient(core core.Client) Client { return Client{core: core} }\n\n")
	buf.WriteString("func (c Client) Core() core.Client { return c.core }\n\n")

	for _, t := range schema.Tables {
		typeName := toExported(t.Name)
		plural := toPlural(typeName)
		queryName := fmt.Sprintf("%sQuery", typeName)
		pageName := fmt.Sprintf("%sPage", typeName)
		pageMapName := fmt.Sprintf("%sMapPage", typeName)

		fmt.Fprintf(&buf, "type %s struct {\n\tItems []%s `json:\"items\"`\n\tNextCursor string `json:\"nextCursor,omitempty\"`\n}\n\n", pageName, typeName)
		fmt.Fprintf(&buf, "type %s struct {\n\tItems []map[string]any `json:\"items\"`\n\tNextCursor string `json:\"nextCursor,omitempty\"`\n}\n\n", pageMapName)
		fmt.Fprintf(&buf, "type %s struct { q core.Query }\n\n", queryName)
		fmt.Fprintf(&buf, "func (q %s) Where(cond core.Condition) %s { q.q = q.q.Where(cond); return q }\n", queryName, queryName)
		fmt.Fprintf(&buf, "func (q %s) And(cond core.Condition) %s { q.q = q.q.And(cond); return q }\n", queryName, queryName)
		fmt.Fprintf(&buf, "func (q %s) Or(cond core.Condition) %s { q.q = q.q.Or(cond); return q }\n", queryName, queryName)
		fmt.Fprintf(&buf, "func (q %s) Resolve(resolvers ...string) %s { q.q = q.q.Resolve(resolvers...); return q }\n", queryName, queryName)
		fmt.Fprintf(&buf, "func (q %s) OrderBy(field string, asc bool) %s {\n\tif asc { q.q = q.q.OrderBy(core.Asc(field)) } else { q.q = q.q.OrderBy(core.Desc(field)) }\n\treturn q\n}\n", queryName, queryName)
		fmt.Fprintf(&buf, "func (q %s) Limit(n int) %s { q.q = q.q.Limit(n); return q }\n", queryName, queryName)
		fmt.Fprintf(&buf, "func (q %s) Select(fields ...string) %s { q.q = q.q.Select(fields...); return q }\n", queryName, queryName)
		fmt.Fprintf(&buf, "func (q %s) GroupBy(fields ...string) %s { q.q = q.q.GroupBy(fields...); return q }\n", queryName, queryName)
		fmt.Fprintf(&buf, "func (q %s) SetUpdates(updates map[string]any) %s { q.q = q.q.SetUpdates(updates); return q }\n", queryName, queryName)
		fmt.Fprintf(&buf, "func (q %s) Stream(ctx context.Context) (core.Iterator, error) { return q.q.Stream(ctx) }\n", queryName)
		fmt.Fprintf(&buf, "func (q %s) List(ctx context.Context) ([]%s, error) {\n\tres := core.List(ctx, q.q)\n\tvar out []%s\n\tif err := res.Decode(&out); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n", queryName, typeName, typeName)
		fmt.Fprintf(&buf, "func (q %s) ListMaps(ctx context.Context) ([]map[string]any, error) {\n\tres := core.List(ctx, q.q)\n\tvar out []map[string]any\n\tif err := res.Decode(&out); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n", queryName)
		fmt.Fprintf(&buf, "func (q %s) ListAggregates(ctx context.Context) ([]map[string]any, error) {\n\tres := core.List(ctx, q.q)\n\tvar out []map[string]any\n\tif err := res.Decode(&out); err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n", queryName)
		fmt.Fprintf(&buf, "func (q %s) Page(ctx context.Context, cursor string) (%s, error) {\n\tres, err := q.q.Page(ctx, cursor)\n\tif err != nil {\n\t\treturn %s{}, err\n\t}\n\tvar items []%s\n\tif err := decodeList(res.Items, &items); err != nil {\n\t\treturn %s{}, err\n\t}\n\treturn %s{Items: items, NextCursor: res.NextCursor}, nil\n}\n\n", queryName, pageName, pageName, typeName, pageName, pageName)
		fmt.Fprintf(&buf, "func (q %s) PageOfMaps(ctx context.Context, cursor string) (%s, error) {\n\tres, err := q.q.Page(ctx, cursor)\n\tif err != nil {\n\t\treturn %s{}, err\n\t}\n\treturn %s{Items: res.Items, NextCursor: res.NextCursor}, nil\n}\n\n", queryName, pageMapName, pageMapName, pageMapName)
		fmt.Fprintf(&buf, "func (q %s) Update(ctx context.Context) (int, error) { return q.q.Update(ctx) }\n\n", queryName)

		fmt.Fprintf(&buf, "func (c Client) List%s() %s {\n\treturn %s{q: c.core.From(Tables.%s)}\n}\n\n", plural, queryName, queryName, typeName)

		deleteName := fmt.Sprintf("%sDelete", typeName)
		fmt.Fprintf(&buf, "type %s struct { q core.Query; ctx context.Context }\n\n", deleteName)
		fmt.Fprintf(&buf, "func (d %s) Where(cond core.Condition) %s { d.q = d.q.Where(cond); return d }\n", deleteName, deleteName)
		fmt.Fprintf(&buf, "func (d %s) And(cond core.Condition) %s { d.q = d.q.And(cond); return d }\n", deleteName, deleteName)
		fmt.Fprintf(&buf, "func (d %s) Or(cond core.Condition) %s { d.q = d.q.Or(cond); return d }\n", deleteName, deleteName)
		fmt.Fprintf(&buf, "func (d %s) Resolve(resolvers ...string) %s { d.q = d.q.Resolve(resolvers...); return d }\n", deleteName, deleteName)
		fmt.Fprintf(&buf, "func (d %s) Limit(n int) %s { d.q = d.q.Limit(n); return d }\n", deleteName, deleteName)
		fmt.Fprintf(&buf, "func (d %s) Delete() (int, error) { return d.q.Delete(d.ctx) }\n\n", deleteName)

		fmt.Fprintf(&buf, "func (c Client) Delete%s(ctx context.Context) %s {\n\treturn %s{q: c.core.From(Tables.%s), ctx: ctx}\n}\n\n", plural, deleteName, deleteName, typeName)
		fmt.Fprintf(&buf, "func (c Client) Save%s(ctx context.Context, item %s, cascades ...core.CascadeSpec) (%s, error) {\n", typeName, typeName, typeName)
		fmt.Fprintf(&buf, "\trelationships := make([]string, 0, len(cascades))\n\tfor _, spec := range cascades {\n\t\tif spec != nil {\n\t\t\trelationships = append(relationships, spec.String())\n\t\t}\n\t}\n\tif len(relationships) == 0 {\n\t\trelationships = nil\n\t}\n\tsaved, err := c.core.Save(ctx, Tables.%s, item, relationships)\n\tif err != nil {\n\t\treturn %s{}, err\n\t}\n\tvar out %s\n\tif err := decodeSaved(saved, &out); err != nil {\n\t\treturn %s{}, err\n\t}\n\treturn out, nil\n}\n\n", typeName, typeName, typeName, typeName)
		fmt.Fprintf(&buf, "func (c Client) Delete%s(ctx context.Context, id string) (int, error) {\n", typeName)
		fmt.Fprintf(&buf, "\tif err := c.core.Delete(ctx, Tables.%s, id); err != nil {\n\t\treturn 0, err\n\t}\n", typeName)
		fmt.Fprintf(&buf, "\treturn 1, nil\n}\n\n")

		// Table-specific service helpers
		serviceName := fmt.Sprintf("%sService", plural)
		fmt.Fprintf(&buf, "type %s struct { core core.Client }\n\n", serviceName)
		fmt.Fprintf(&buf, "func (c Client) %s() %s { return %s{core: c.core} }\n\n", plural, serviceName, serviceName)
		cascadeName := fmt.Sprintf("%sCascade", typeName)
		fmt.Fprintf(&buf, "type %s struct { core core.Client; spec core.CascadeSpec }\n\n", cascadeName)
		fmt.Fprintf(&buf, "func (s %s) Cascade(spec core.CascadeSpec) %s { return %s{core: s.core, spec: spec} }\n\n", serviceName, cascadeName, cascadeName)
		fmt.Fprintf(&buf, "func (c %s) Save(ctx context.Context, item %s) error { return c.core.Cascade(c.spec).Save(ctx, Tables.%s, item) }\n\n", cascadeName, typeName, typeName)
	}

	buf.WriteString("func decodeSaved(saved map[string]any, out any) error {\n\tb, err := json.Marshal(saved)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(b, out)\n}\n\n")
	buf.WriteString("func decodeList(items []map[string]any, out any) error {\n\tb, err := json.Marshal(items)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(b, out)\n}\n\n")

	// Documents passthrough helpers
	buf.WriteString("type DocumentsClient struct { core core.DocumentClient }\n\n")
	buf.WriteString("func (c Client) Documents() DocumentsClient { return DocumentsClient{core: c.core.Documents()} }\n\n")
	buf.WriteString("func (d DocumentsClient) List(ctx context.Context) ([]core.Document, error) { return d.core.List(ctx) }\n")
	buf.WriteString("func (d DocumentsClient) Get(ctx context.Context, id string) (core.Document, error) { return d.core.Get(ctx, id) }\n")
	buf.WriteString("func (d DocumentsClient) Save(ctx context.Context, doc core.Document) (core.Document, error) { return d.core.Save(ctx, doc) }\n")
	buf.WriteString("func (d DocumentsClient) Delete(ctx context.Context, id string) error { return d.core.Delete(ctx, id) }\n\n")

	// Secrets passthrough helpers
	buf.WriteString("type SecretsClient struct { core core.Client }\n\n")
	buf.WriteString("func (c Client) Secrets() SecretsClient { return SecretsClient{core: c.core} }\n\n")
	buf.WriteString("func (s SecretsClient) List(ctx context.Context) ([]core.Secret, error) { return s.core.ListSecrets(ctx) }\n")
	buf.WriteString("func (s SecretsClient) Get(ctx context.Context, key string) (core.Secret, error) { return s.core.GetSecret(ctx, key) }\n")
	buf.WriteString("func (s SecretsClient) Set(ctx context.Context, secret core.Secret) (core.Secret, error) { return s.core.PutSecret(ctx, secret) }\n")
	buf.WriteString("func (s SecretsClient) Delete(ctx context.Context, key string) error { return s.core.DeleteSecret(ctx, key) }\n\n")

	return buf.Bytes()
}

func toExported(name string) string {
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsDigit(r)
	})
	var b strings.Builder
	for _, p := range parts {
		if p == "" {
			continue
		}
		r, size := utf8.DecodeRuneInString(p)
		b.WriteRune(unicode.ToUpper(r))
		b.WriteString(p[size:])
	}
	if b.Len() == 0 {
		return "Name"
	}
	return b.String()
}

func mapFieldType(f core.Field, timestampFormat string) string {
	kind := strings.ToLower(strings.TrimSpace(f.Type))
	switch kind {
	case "string":
		if f.Nullable {
			return "*string"
		}
		return "string"
	case "boolean", "bool":
		if f.Nullable {
			return "*bool"
		}
		return "bool"
	case "int", "integer":
		if f.Nullable {
			return "*int64"
		}
		return "int64"
	case "timestamp", "datetime", "date", "time":
		if strings.ToLower(timestampFormat) == "string" {
			if f.Nullable {
				return "*string"
			}
			return "string"
		}
		if f.Nullable {
			return "*time.Time"
		}
		return "time.Time"
	case "embeddedobject", "object", "json", "map", "any":
		return "map[string]any"
	default:
		return "any"
	}
}

func needsTime(schema core.Schema, timestampFormat string) bool {
	if strings.ToLower(timestampFormat) == "string" {
		return false
	}
	for _, t := range schema.Tables {
		for _, f := range t.Fields {
			kind := strings.ToLower(strings.TrimSpace(f.Type))
			if kind == "timestamp" || kind == "datetime" || kind == "date" || kind == "time" {
				return true
			}
		}
	}
	return false
}

func hasResolvers(schema core.Schema) bool {
	for _, t := range schema.Tables {
		if len(t.Resolvers) > 0 {
			return true
		}
	}
	return false
}

func toPlural(name string) string {
	if strings.HasSuffix(name, "s") {
		return name
	}
	return name + "s"
}

func clientOutPath(outDir string) string {
	return filepath.Join(outDir, "client.go")
}

// ClientPathFor exposes the client path calculation for external callers.
func ClientPathFor(outDir string) string {
	return clientOutPath(outDir)
}
