package generator

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

// Options captures configuration for the Go code generator.
type Options struct {
	SchemaPath          string
	Source              string
	DatabaseID          string
	OutPath             string // directory where generated files are written
	PackageName         string
	Tables              []string
	TimestampFormat     string
}

// Run validates the provided options and performs generation.
func Run(opts Options) error {
	if err := ValidateOptions(&opts); err != nil {
		return err
	}

	schema, err := loadSchema(context.Background(), opts)
	if err != nil {
		return err
	}

	if err := os.MkdirAll(opts.OutPath, 0o755); err != nil {
		return err
	}

	commonPath := filepath.Join(opts.OutPath, "common.go")
	commonCode := renderCommon(schema, opts.PackageName)
	if err := os.WriteFile(commonPath, commonCode, 0o644); err != nil {
		return err
	}

	for _, t := range schema.Tables {
		tablePath := filepath.Join(opts.OutPath, fmt.Sprintf("%s.go", toFileName(t.Name)))
		tableCode := renderTable(t, opts.PackageName, opts.TimestampFormat)
		if err := os.WriteFile(tablePath, tableCode, 0o644); err != nil {
			return err
		}
	}

	return nil
}

// ValidateOptions ensures the provided options meet the CLI requirements.
func ValidateOptions(opts *Options) error {
	if opts == nil {
		return fmt.Errorf("options cannot be nil")
	}

	if opts.TimestampFormat == "" {
		opts.TimestampFormat = "time"
	}

	if opts.TimestampFormat != "time" && opts.TimestampFormat != "string" {
		return fmt.Errorf("invalid --timestamps value %q (must be \"time\" or \"string\")", opts.TimestampFormat)
	}

	opts.Source = strings.ToLower(strings.TrimSpace(opts.Source))
	if opts.Source == "" {
		opts.Source = "file"
	}

	if opts.Source != "file" && opts.Source != "api" {
		return fmt.Errorf("invalid --source value %q (must be \"file\" or \"api\")", opts.Source)
	}

	if opts.OutPath == "" {
		opts.OutPath = "./gen/onyx"
	}

	if opts.PackageName == "" {
		opts.PackageName = "onyx"
	}

	if opts.SchemaPath == "" {
		opts.SchemaPath = "./api/onyx.schema.json"
	}

	return nil
}

func renderCommon(schema onyx.Schema, pkg string) []byte {
	var buf bytes.Buffer
	generatedAt := generatedTimestamp()
	buf.WriteString("// Code generated by onyx-gen-go; DO NOT EDIT.\n")
	buf.WriteString("// Generated at: " + generatedAt + "\n\n")
	buf.WriteString("package " + pkg + "\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"time\"\n")
	buf.WriteString("\t\"github.com/OnyxDevTools/onyx-database-go/onyx\"\n")
	buf.WriteString(")\n\n")

	buf.WriteString("// QueryHook allows callers to observe query execution for logging, metrics, or tracing.\n")
	buf.WriteString("// The returned context from BeforeQuery will be used for the operation and passed to AfterQuery.\n")
	buf.WriteString("type QueryHook interface {\n")
	buf.WriteString("\tBeforeQuery(ctx context.Context, operation, table string) context.Context\n")
	buf.WriteString("\tAfterQuery(ctx context.Context, operation, table string, duration time.Duration, err error)\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func withContextAndHook(ctx context.Context, timeout time.Duration, hook QueryHook, operation, table string) (context.Context, func(error)) {\n")
	buf.WriteString("\tvar cancel context.CancelFunc\n")
	buf.WriteString("\tif timeout > 0 {\n")
	buf.WriteString("\t\tctx, cancel = context.WithTimeout(ctx, timeout)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tstart := time.Now()\n")
	buf.WriteString("\tif hook != nil {\n")
	buf.WriteString("\t\tctx = hook.BeforeQuery(ctx, operation, table)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn ctx, func(err error) {\n")
	buf.WriteString("\t\tif hook != nil {\n")
	buf.WriteString("\t\t\thook.AfterQuery(ctx, operation, table, time.Since(start), err)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tif cancel != nil {\n")
	buf.WriteString("\t\t\tcancel()\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func Eq(field string, value any) onyx.Condition { return onyx.Eq(field, value) }\n")
	buf.WriteString("func Neq(field string, value any) onyx.Condition { return onyx.Neq(field, value) }\n")
	buf.WriteString("func In(field string, values []any) onyx.Condition { return onyx.In(field, values) }\n")
	buf.WriteString("func NotIn(field string, values []any) onyx.Condition { return onyx.NotIn(field, values) }\n")
	buf.WriteString("func Between(field string, from, to any) onyx.Condition { return onyx.Between(field, from, to) }\n")
	buf.WriteString("func Gt(field string, value any) onyx.Condition { return onyx.Gt(field, value) }\n")
	buf.WriteString("func Gte(field string, value any) onyx.Condition { return onyx.Gte(field, value) }\n")
	buf.WriteString("func Lt(field string, value any) onyx.Condition { return onyx.Lt(field, value) }\n")
	buf.WriteString("func Lte(field string, value any) onyx.Condition { return onyx.Lte(field, value) }\n")
	buf.WriteString("func Like(field string, pattern any) onyx.Condition { return onyx.Like(field, pattern) }\n")
	buf.WriteString("func Contains(field string, value any) onyx.Condition { return onyx.Contains(field, value) }\n")
	buf.WriteString("func StartsWith(field string, value any) onyx.Condition { return onyx.StartsWith(field, value) }\n")
	buf.WriteString("func IsNull(field string) onyx.Condition { return onyx.IsNull(field) }\n")
	buf.WriteString("func NotNull(field string) onyx.Condition { return onyx.NotNull(field) }\n")
	buf.WriteString("func Within(field string, query onyx.Query) onyx.Condition { return onyx.Within(field, query) }\n")
	buf.WriteString("func NotWithin(field string, query onyx.Query) onyx.Condition { return onyx.NotWithin(field, query) }\n")
	buf.WriteString("func Asc(field string) onyx.Sort { return onyx.Asc(field) }\n")
	buf.WriteString("func Desc(field string) onyx.Sort { return onyx.Desc(field) }\n")
	buf.WriteString("func Cascade(spec string) onyx.CascadeSpec { return onyx.Cascade(spec) }\n")
	buf.WriteString("func NewCascadeBuilder() onyx.CascadeBuilder { return onyx.NewCascadeBuilder() }\n\n")

	buf.WriteString("type Schema = onyx.Schema\n")
	buf.WriteString("type Table = onyx.Table\n")
	buf.WriteString("type Field = onyx.Field\n")
	buf.WriteString("type Resolver = onyx.Resolver\n")
	buf.WriteString("type Document = onyx.Document\n")
	buf.WriteString("type Secret = onyx.Secret\n\n")

	buf.WriteString("var Tables = struct {\n")
	for _, t := range schema.Tables {
		fmt.Fprintf(&buf, "\t%s string\n", toExported(t.Name))
	}
	buf.WriteString("}{\n")
	for _, t := range schema.Tables {
		fmt.Fprintf(&buf, "\t%s: %q,\n", toExported(t.Name), t.Name)
	}
	buf.WriteString("}\n\n")

	if hasResolvers(schema) {
		buf.WriteString("var Resolvers = map[string][]string{\n")
		for _, t := range schema.Tables {
			if len(t.Resolvers) == 0 {
				continue
			}
			buf.WriteString(fmt.Sprintf("\t%q: {", t.Name))
			for i, r := range t.Resolvers {
				if i > 0 {
					buf.WriteString(", ")
				}
				buf.WriteString(fmt.Sprintf("%q", r.Name))
			}
			buf.WriteString("},\n")
		}
		buf.WriteString("}\n\n")
	}

	buf.WriteString("// DB exposes typed table clients backed by the underlying Onyx core client.\n")
	buf.WriteString("type DB struct { core onyx.Client }\n\n")
	buf.WriteString("type Config = onyx.Config\n\n")
	buf.WriteString("func New(ctx context.Context, cfg Config) (DB, error) {\n")
	buf.WriteString("\tcore, err := onyx.Init(ctx, cfg)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn DB{}, err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn DB{core: core}, nil\n")
	buf.WriteString("}\n\n")
	buf.WriteString("func Wrap(core onyx.Client) DB { return DB{core: core} }\n\n")
	buf.WriteString("func (c DB) Core() onyx.Client { return c.core }\n\n")

	buf.WriteString("func decodeSaved(saved map[string]any, out any) error {\n\tb, err := json.Marshal(saved)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(b, out)\n}\n\n")
	buf.WriteString("func decodeList(items []map[string]any, out any) error {\n\tb, err := json.Marshal(items)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(b, out)\n}\n\n")

	buf.WriteString("func toAnyStrings(values []string) []any {\n\tout := make([]any, 0, len(values))\n\tfor _, v := range values {\n\t\tout = append(out, v)\n\t}\n\treturn out\n}\n\n")

	buf.WriteString("func parseCount(v any) (int, error) {\n\tswitch n := v.(type) {\n\tcase int:\n\t\treturn n, nil\n\tcase int64:\n\t\treturn int(n), nil\n\tcase float64:\n\t\treturn int(n), nil\n\tcase json.Number:\n\t\tparsed, err := n.Int64()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn int(parsed), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"cannot parse count from %T\", v)\n\t}\n}\n\n")

	buf.WriteString("type DocumentsClient struct { core onyx.DocumentClient }\n\n")
	buf.WriteString("func (c DB) Documents() DocumentsClient { return DocumentsClient{core: c.core.Documents()} }\n\n")
	buf.WriteString("func (d DocumentsClient) List(ctx context.Context) ([]onyx.Document, error) { return d.core.List(ctx) }\n")
	buf.WriteString("func (d DocumentsClient) Get(ctx context.Context, id string) (onyx.Document, error) { return d.core.Get(ctx, id) }\n")
	buf.WriteString("func (d DocumentsClient) Save(ctx context.Context, doc onyx.Document) (onyx.Document, error) { return d.core.Save(ctx, doc) }\n")
	buf.WriteString("func (d DocumentsClient) Delete(ctx context.Context, id string) error { return d.core.Delete(ctx, id) }\n\n")

	buf.WriteString("type SecretsClient struct { core onyx.Client }\n\n")
	buf.WriteString("func (c DB) Secrets() SecretsClient { return SecretsClient{core: c.core} }\n\n")
	buf.WriteString("func (s SecretsClient) List(ctx context.Context) ([]onyx.Secret, error) { return s.core.ListSecrets(ctx) }\n")
	buf.WriteString("func (s SecretsClient) Get(ctx context.Context, key string) (onyx.Secret, error) { return s.core.GetSecret(ctx, key) }\n")
	buf.WriteString("func (s SecretsClient) Set(ctx context.Context, secret onyx.Secret) (onyx.Secret, error) { return s.core.PutSecret(ctx, secret) }\n")
	buf.WriteString("func (s SecretsClient) Delete(ctx context.Context, key string) error { return s.core.DeleteSecret(ctx, key) }\n\n")

	return buf.Bytes()
}

func renderTable(table onyx.Table, pkg, timestampFormat string) []byte {
	var buf bytes.Buffer
	generatedAt := time.Now().UTC().Format(time.RFC3339)
	buf.WriteString("// Code generated by onyx-gen-go; DO NOT EDIT.\n")
	buf.WriteString("// Generated at: " + generatedAt + "\n\n")
	buf.WriteString("package " + pkg + "\n\n")

	imports := []string{"context", "time", "fmt", "github.com/OnyxDevTools/onyx-database-go/onyx"}
	buf.WriteString("import (\n")
	for _, imp := range imports {
		fmt.Fprintf(&buf, "\t%q\n", imp)
	}
	buf.WriteString(")\n\n")

	typeName := toExported(table.Name)
	pageName := fmt.Sprintf("%sPage", typeName)
	pageMapName := fmt.Sprintf("%sMapPage", typeName)
	plural := toPlural(typeName)
	resourceName := fmt.Sprintf("%sClient", plural)
	mapResourceName := fmt.Sprintf("%sMapClient", plural)
	pageIterName := fmt.Sprintf("%sPageIterator", plural)
	pageMapIterName := fmt.Sprintf("%sMapPageIterator", plural)
	repoName := fmt.Sprintf("%sRepository", typeName)
	updatesName := fmt.Sprintf("%sUpdates", typeName)
	hasEmail := hasField(table, "email")
	hasActive := hasField(table, "isActive")
	typeLabel := strings.ToLower(typeName)
	requiredStrings := requiredStringFields(table)

	fmt.Fprintf(&buf, "type %s struct {\n", typeName)
	for _, f := range table.Fields {
		fieldName := toExported(f.Name)
		goType := mapFieldType(f, timestampFormat)
		fmt.Fprintf(&buf, "\t%s %s `json:\"%s,omitempty\"`\n", fieldName, goType, f.Name)
	}
	for _, r := range table.Resolvers {
		fieldName := toExported(r.Name)
		fmt.Fprintf(&buf, "\t%s any `json:\"%s,omitempty\"`\n", fieldName, r.Name)
	}
	buf.WriteString("}\n\n")

	fmt.Fprintf(&buf, "// %s provides typed setters for update operations on %s.\n", updatesName, typeName)
	fmt.Fprintf(&buf, "type %s struct { values map[string]any }\n\n", updatesName)

	fmt.Fprintf(&buf, "func New%sUpdates() *%s { return &%s{values: make(map[string]any)} }\n\n", typeName, updatesName, updatesName)

	for _, f := range table.Fields {
		fieldName := toExported(f.Name)
		goType := mapFieldType(f, timestampFormat)
		fmt.Fprintf(&buf, "func (u *%s) Set%s(v %s) *%s {\n", updatesName, fieldName, goType, updatesName)
		fmt.Fprintf(&buf, "\tif u.values == nil { u.values = make(map[string]any) }\n")
		fmt.Fprintf(&buf, "\tu.values[\"%s\"] = v\n\treturn u\n}\n\n", f.Name)
	}

	fmt.Fprintf(&buf, "func (u *%s) valuesMap() map[string]any { return u.values }\n\n", updatesName)

	fmt.Fprintf(&buf, "type %s struct {\n\tItems []%s `json:\"items\"`\n\tNextCursor string `json:\"nextCursor,omitempty\"`\n}\n\n", pageName, typeName)
	fmt.Fprintf(&buf, "type %s struct {\n\tItems []map[string]any `json:\"items\"`\n\tNextCursor string `json:\"nextCursor,omitempty\"`\n}\n\n", pageMapName)

	if len(requiredStrings) > 0 {
		fmt.Fprintf(&buf, "func validate%s(item %s) error {\n", typeName, typeName)
		for _, f := range requiredStrings {
			fieldName := toExported(f.Name)
			fmt.Fprintf(&buf, "\tif item.%s == \"\" {\n\t\treturn fmt.Errorf(\"%s %s is required\")\n\t}\n", fieldName, typeLabel, f.Name)
		}
		fmt.Fprintf(&buf, "\treturn nil\n}\n\n")
	}

	fmt.Fprintf(&buf, "// %s provides a fluent API for querying and manipulating %s records.\n", resourceName, typeName)
	fmt.Fprintf(&buf, "// All methods return a new client instance, allowing for method chaining.\n")
	fmt.Fprintf(&buf, "//\n// Example:\n")
	fmt.Fprintf(&buf, "//   items, err := db.%s().\n//       Where(onyx.Eq(\"isActive\", true)).\n//       OrderBy(\"createdAt\", false).\n//       Limit(10).\n//       List(ctx)\n", plural)
	fmt.Fprintf(&buf, "type %s struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }\n", resourceName)

	fmt.Fprintf(&buf, "// %s provides map-based query helpers returned from Select/GroupBy operations.\n", mapResourceName)
	fmt.Fprintf(&buf, "type %s struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }\n\n", mapResourceName)

	fmt.Fprintf(&buf, "// %s captures the full set of %s operations for easy mocking in tests.\n", repoName, resourceName)
	fmt.Fprintf(&buf, "type %s interface {\n", repoName)
	fmt.Fprintf(&buf, "\tWhere(cond onyx.Condition) %s\n", resourceName)
	fmt.Fprintf(&buf, "\tAnd(cond onyx.Condition) %s\n", resourceName)
	fmt.Fprintf(&buf, "\tOr(cond onyx.Condition) %s\n", resourceName)
	fmt.Fprintf(&buf, "\tResolve(resolvers ...string) %s\n", resourceName)
	fmt.Fprintf(&buf, "\tOrderBy(field string, asc bool) %s\n", resourceName)
	fmt.Fprintf(&buf, "\tLimit(n int) %s\n", resourceName)
	fmt.Fprintf(&buf, "\tSetUpdates(updates map[string]any) %s\n", resourceName)
	fmt.Fprintf(&buf, "\tSet%sUpdates(updates *%s) %s\n", typeName, updatesName, resourceName)
	fmt.Fprintf(&buf, "\tSelect(fields ...string) %s\n", mapResourceName)
	fmt.Fprintf(&buf, "\tGroupBy(fields ...string) %s\n", mapResourceName)
	fmt.Fprintf(&buf, "\tAsMaps() %s\n", mapResourceName)
	fmt.Fprintf(&buf, "\tWithTimeout(d time.Duration) %s\n", resourceName)
	fmt.Fprintf(&buf, "\tWithDefaultTimeout() %s\n", resourceName)
	fmt.Fprintf(&buf, "\tWithShortTimeout() %s\n", resourceName)
	fmt.Fprintf(&buf, "\tWithLongTimeout() %s\n", resourceName)
	fmt.Fprintf(&buf, "\tWithHook(h QueryHook) %s\n", resourceName)
	fmt.Fprintf(&buf, "\tStream(ctx context.Context) (onyx.Iterator, error)\n")
	fmt.Fprintf(&buf, "\tList(ctx context.Context) ([]%s, error)\n", typeName)
	fmt.Fprintf(&buf, "\tListMaps(ctx context.Context) ([]map[string]any, error)\n")
	fmt.Fprintf(&buf, "\tPage(ctx context.Context, cursor string) (%s, error)\n", pageName)
	fmt.Fprintf(&buf, "\tPages(ctx context.Context) *%s\n", pageIterName)
	fmt.Fprintf(&buf, "\tPageOfMaps(ctx context.Context, cursor string) (%s, error)\n", pageMapName)
	fmt.Fprintf(&buf, "\tUpdate(ctx context.Context) (int, error)\n")
	fmt.Fprintf(&buf, "\tDelete(ctx context.Context) (int, error)\n")
	fmt.Fprintf(&buf, "\tSave(ctx context.Context, item %s, cascades ...onyx.CascadeSpec) (%s, error)\n", typeName, typeName)
	fmt.Fprintf(&buf, "\tSaveMany(ctx context.Context, items []%s, cascades ...onyx.CascadeSpec) ([]%s, error)\n", typeName, typeName)
	fmt.Fprintf(&buf, "\tDeleteByID(ctx context.Context, id string) (int, error)\n")
	fmt.Fprintf(&buf, "\tDeleteByIDs(ctx context.Context, ids []string) (int, error)\n")
	fmt.Fprintf(&buf, "\tFindByID(ctx context.Context, id string) (%s, error)\n", typeName)
	if hasEmail {
		fmt.Fprintf(&buf, "\tFindByEmail(ctx context.Context, email string) (%s, error)\n", typeName)
	}
	if hasActive {
		fmt.Fprintf(&buf, "\tFindActiveUsers(ctx context.Context) ([]%s, error)\n", typeName)
		fmt.Fprintf(&buf, "\tCountActive(ctx context.Context) (int, error)\n")
	}
	fmt.Fprintf(&buf, "}\n\n")

	fmt.Fprintf(&buf, "// %s iterates over paginated %s results.\n", pageIterName, typeName)
	fmt.Fprintf(&buf, "type %s struct {\n\tclient %s\n\tctx context.Context\n\tcursor string\n\tstarted bool\n\tpage %s\n\terr error\n}\n\n", pageIterName, resourceName, pageName)

	fmt.Fprintf(&buf, "// %s iterates over paginated map results for %s queries.\n", pageMapIterName, typeName)
	fmt.Fprintf(&buf, "type %s struct {\n\tclient %s\n\tctx context.Context\n\tcursor string\n\tstarted bool\n\tpage %s\n\terr error\n}\n\n", pageMapIterName, mapResourceName, pageMapName)

	fmt.Fprintf(&buf, "// %s returns a typed client scoped to the %s table.\n", plural, typeName)
	fmt.Fprintf(&buf, "func (c DB) %s() %s { return %s{core: c.core, q: c.core.From(Tables.%s)} }\n\n", plural, resourceName, resourceName, typeName)

	fmt.Fprintf(&buf, "func (c %s) Where(cond onyx.Condition) %s { c.q = c.q.Where(cond); return c }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) And(cond onyx.Condition) %s { c.q = c.q.And(cond); return c }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) Or(cond onyx.Condition) %s { c.q = c.q.Or(cond); return c }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) Resolve(resolvers ...string) %s { c.q = c.q.Resolve(resolvers...); return c }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) OrderBy(field string, asc bool) %s {\n\tif asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }\n\treturn c\n}\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) Limit(n int) %s { c.q = c.q.Limit(n); return c }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) SetUpdates(updates map[string]any) %s { c.q = c.q.SetUpdates(updates); return c }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) Set%sUpdates(updates *%s) %s {\n\tif updates == nil {\n\t\treturn c\n\t}\n\tc.q = c.q.SetUpdates(updates.valuesMap())\n\treturn c\n}\n", resourceName, typeName, updatesName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) Select(fields ...string) %s {\n\tc.q = c.q.Select(fields...)\n\treturn %s{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}\n}\n", resourceName, mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) GroupBy(fields ...string) %s {\n\tc.q = c.q.GroupBy(fields...)\n\treturn %s{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}\n}\n", resourceName, mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) AsMaps() %s { return %s{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }\n", resourceName, mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) WithTimeout(d time.Duration) %s {\n\tif d <= 0 {\n\t\tc.timeout = 30 * time.Second\n\t\treturn c\n\t}\n\tc.timeout = d\n\treturn c\n}\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) WithDefaultTimeout() %s { return c.WithTimeout(30 * time.Second) }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) WithShortTimeout() %s { return c.WithTimeout(5 * time.Second) }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) WithLongTimeout() %s { return c.WithTimeout(2 * time.Minute) }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) WithHook(h QueryHook) %s { c.hook = h; return c }\n", resourceName, resourceName)
	fmt.Fprintf(&buf, "func (c %s) Stream(ctx context.Context) (onyx.Iterator, error) {\n\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"stream\", Tables.%s)\n\titer, err := c.q.Stream(ctx)\n\tdone(err)\n\treturn iter, err\n}\n", resourceName, typeName)
	fmt.Fprintf(&buf, "func (c %s) List(ctx context.Context) ([]%s, error) {\n\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"list\", Tables.%s)\n\tres := onyx.List(ctx, c.q)\n\tvar out []%s\n\terr := res.Decode(&out)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to decode %s list: %%w\", err)\n\t\tdone(err)\n\t\treturn nil, err\n\t}\n\tdone(nil)\n\treturn out, nil\n}\n\n", resourceName, typeName, typeName, typeName, typeName)
	fmt.Fprintf(&buf, "func (c %s) ListMaps(ctx context.Context) ([]map[string]any, error) {\n\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"list_maps\", Tables.%s)\n\tres := onyx.List(ctx, c.q)\n\tvar out []map[string]any\n\terr := res.Decode(&out)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to decode %s map list: %%w\", err)\n\t\tdone(err)\n\t\treturn nil, err\n\t}\n\tdone(nil)\n\treturn out, nil\n}\n\n", resourceName, typeName, typeName)
	fmt.Fprintf(&buf, "func (c %s) Page(ctx context.Context, cursor string) (%s, error) {\n", resourceName, pageName)
	fmt.Fprintf(&buf, "\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"page\", Tables.%s)\n", typeName)
	fmt.Fprintf(&buf, "\tres, err := c.q.Page(ctx, cursor)\n")
	fmt.Fprintf(&buf, "\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to page %s: %%w\", err)\n\t\tdone(err)\n\t\treturn %s{}, err\n\t}\n", typeLabel, pageName)
	fmt.Fprintf(&buf, "\tif res.Items == nil {\n\t\tdone(nil)\n\t\treturn %s{Items: []%s{}, NextCursor: res.NextCursor}, nil\n\t}\n", pageName, typeName)
	fmt.Fprintf(&buf, "\tvar items []%s\n", typeName)
	fmt.Fprintf(&buf, "\tif err := decodeList(res.Items, &items); err != nil {\n\t\terr = fmt.Errorf(\"failed to decode %s page: %%w\", err)\n\t\tdone(err)\n\t\treturn %s{}, err\n\t}\n", typeLabel, pageName)
	fmt.Fprintf(&buf, "\tdone(nil)\n\treturn %s{Items: items, NextCursor: res.NextCursor}, nil\n}\n\n", pageName)
	fmt.Fprintf(&buf, "func (c %s) Pages(ctx context.Context) *%s { return &%s{client: c, ctx: ctx} }\n\n", resourceName, pageIterName, pageIterName)
	fmt.Fprintf(&buf, "func (c %s) PageOfMaps(ctx context.Context, cursor string) (%s, error) {\n", resourceName, pageMapName)
	fmt.Fprintf(&buf, "\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"page\", Tables.%s)\n", typeName)
	fmt.Fprintf(&buf, "\tres, err := c.q.Page(ctx, cursor)\n")
	fmt.Fprintf(&buf, "\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to page %s maps: %%w\", err)\n\t\tdone(err)\n\t\treturn %s{}, err\n\t}\n", typeLabel, pageMapName)
	fmt.Fprintf(&buf, "\tif res.Items == nil {\n\t\tdone(nil)\n\t\treturn %s{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil\n\t}\n", pageMapName)
	fmt.Fprintf(&buf, "\tdone(nil)\n\treturn %s{Items: res.Items, NextCursor: res.NextCursor}, nil\n}\n\n", pageMapName)
	fmt.Fprintf(&buf, "func (c %s) Update(ctx context.Context) (int, error) {\n\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"update\", Tables.%s)\n\tn, err := c.q.Update(ctx)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to update %s: %%w\", err)\n\t\tdone(err)\n\t\treturn 0, err\n\t}\n\tdone(nil)\n\treturn n, nil\n}\n\n", resourceName, typeName, typeName)
	fmt.Fprintf(&buf, "func (c %s) Delete(ctx context.Context) (int, error) {\n\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"delete\", Tables.%s)\n\tn, err := c.q.Delete(ctx)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to delete %s: %%w\", err)\n\t\tdone(err)\n\t\treturn 0, err\n\t}\n\tdone(nil)\n\treturn n, nil\n}\n\n", resourceName, typeName, typeName)
	buf.WriteString(fmt.Sprintf("func (c %s) Save(ctx context.Context, item %s, cascades ...onyx.CascadeSpec) (%s, error) {\n", resourceName, typeName, typeName))
	if len(requiredStrings) > 0 {
		buf.WriteString(fmt.Sprintf("\tif err := validate%s(item); err != nil {\n\t\treturn %s{}, err\n\t}\n", typeName, typeName))
	}
	buf.WriteString("\tvar relationships []string\n\tfor i, spec := range cascades {\n\t\tif spec == nil {\n\t\t\treturn ")
	buf.WriteString(fmt.Sprintf("%s{}, fmt.Errorf(\"cascade spec at index %%d is nil\", i)\n\t\t}\n\t\trelationships = append(relationships, spec.String())\n\t}\n", typeName))
	buf.WriteString(fmt.Sprintf("\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"save\", Tables.%s)\n", typeName))
	buf.WriteString(fmt.Sprintf("\tsaved, err := c.core.Save(ctx, Tables.%s, item, relationships)\n", typeName))
	buf.WriteString(fmt.Sprintf("\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to save %s: %%w\", err)\n\t\tdone(err)\n\t\treturn %s{}, err\n\t}\n", typeLabel, typeName))
	buf.WriteString(fmt.Sprintf("\tvar out %s\n", typeName))
	buf.WriteString(fmt.Sprintf("\tif err := decodeSaved(saved, &out); err != nil {\n\t\terr = fmt.Errorf(\"failed to decode saved %s: %%w\", err)\n\t\tdone(err)\n\t\treturn %s{}, err\n\t}\n", typeLabel, typeName))
	buf.WriteString("\tdone(nil)\n\treturn out, nil\n}\n\n")
	buf.WriteString(fmt.Sprintf("func (c %s) SaveMany(ctx context.Context, items []%s, cascades ...onyx.CascadeSpec) ([]%s, error) {\n", resourceName, typeName, typeName))
	buf.WriteString("\tif len(items) == 0 {\n\t\treturn nil, nil\n\t}\n")
	if len(requiredStrings) > 0 {
		buf.WriteString(fmt.Sprintf("\tfor i, item := range items {\n\t\tif err := validate%s(item); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"%s at index %%d: %%w\", i, err)\n\t\t}\n\t}\n", typeName, typeLabel))
	}
	buf.WriteString("\tvar relationships []string\n\tfor i, spec := range cascades {\n\t\tif spec == nil {\n\t\t\treturn nil, fmt.Errorf(\"cascade spec at index %d is nil\", i)\n\t\t}\n\t\trelationships = append(relationships, spec.String())\n\t}\n")
	buf.WriteString(fmt.Sprintf("\tout := make([]%s, 0, len(items))\n", typeName))
	buf.WriteString("\tfor i, item := range items {\n")
	buf.WriteString(fmt.Sprintf("\t\tctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, \"save_many\", Tables.%s)\n", typeName))
	buf.WriteString(fmt.Sprintf("\t\tsaved, err := c.core.Save(ctxOp, Tables.%s, item, relationships)\n", typeName))
	buf.WriteString(fmt.Sprintf("\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"failed to save %s at index %%d: %%w\", i, err)\n\t\t\tdone(err)\n\t\t\treturn nil, err\n\t\t}\n", typeLabel))
	buf.WriteString(fmt.Sprintf("\t\tvar decoded %s\n", typeName))
	buf.WriteString(fmt.Sprintf("\t\tif err := decodeSaved(saved, &decoded); err != nil {\n\t\t\terr = fmt.Errorf(\"failed to decode saved %s at index %%d: %%w\", i, err)\n\t\t\tdone(err)\n\t\t\treturn nil, err\n\t\t}\n", typeLabel))
	buf.WriteString("\t\tdone(nil)\n\t\tout = append(out, decoded)\n\t}\n\treturn out, nil\n}\n\n")
	buf.WriteString(fmt.Sprintf("func (c %s) DeleteByID(ctx context.Context, id string) (int, error) {\n", resourceName))
	buf.WriteString(fmt.Sprintf("\tif id == \"\" {\n\t\treturn 0, fmt.Errorf(\"%s id cannot be empty\")\n\t}\n", typeLabel))
	buf.WriteString(fmt.Sprintf("\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"delete_by_id\", Tables.%s)\n", typeName))
	buf.WriteString(fmt.Sprintf("\terr := c.core.Delete(ctx, Tables.%s, id)\n", typeName))
	buf.WriteString(fmt.Sprintf("\tif err != nil {\n\t\terr = fmt.Errorf(%q, id, err)\n\t\tdone(err)\n\t\treturn 0, err\n\t}\n", fmt.Sprintf("failed to delete %s %%s: %%w", typeLabel)))
	buf.WriteString("\tdone(nil)\n\treturn 1, nil\n}\n\n")

	buf.WriteString(fmt.Sprintf("func (c %s) DeleteByIDs(ctx context.Context, ids []string) (int, error) {\n", resourceName))
	buf.WriteString("\tif len(ids) == 0 {\n\t\treturn 0, nil\n\t}\n")
	buf.WriteString("\tfor i, id := range ids {\n\t\tif id == \"\" {\n\t\t\treturn 0, fmt.Errorf(\"id at index %d is empty\", i)\n\t\t}\n\t}\n")
	buf.WriteString(fmt.Sprintf("\tclient := c.Where(onyx.In(\"id\", toAnyStrings(ids)))\n\tctx, done := withContextAndHook(ctx, client.timeout, client.hook, \"delete_many\", Tables.%s)\n", typeName))
	buf.WriteString("\tn, err := client.q.Delete(ctx)\n")
	buf.WriteString(fmt.Sprintf("\tif err != nil {\n\t\terr = fmt.Errorf(%q, err)\n\t\tdone(err)\n\t\treturn 0, err\n\t}\n", fmt.Sprintf("failed to delete %s by ids: %%w", typeLabel)))
	buf.WriteString("\tdone(nil)\n\treturn n, nil\n}\n\n")

	buf.WriteString(fmt.Sprintf("func (c %s) FindByID(ctx context.Context, id string) (%s, error) {\n", resourceName, typeName))
	buf.WriteString(fmt.Sprintf("\tif id == \"\" {\n\t\treturn %s{}, fmt.Errorf(\"%s id cannot be empty\")\n\t}\n", typeName, typeLabel))
	buf.WriteString("\titems, err := c.Where(onyx.Eq(\"id\", id)).Limit(1).List(ctx)\n")
	buf.WriteString(fmt.Sprintf("\tif err != nil {\n\t\treturn %s{}, fmt.Errorf(%q, id, err)\n\t}\n", typeName, fmt.Sprintf("failed to find %s by id %%s: %%w", typeLabel)))
	buf.WriteString(fmt.Sprintf("\tif len(items) == 0 {\n\t\treturn %s{}, nil\n\t}\n\treturn items[0], nil\n}\n\n", typeName))

	if hasEmail {
		buf.WriteString(fmt.Sprintf("func (c %s) FindByEmail(ctx context.Context, email string) (%s, error) {\n", resourceName, typeName))
		buf.WriteString(fmt.Sprintf("\tif email == \"\" {\n\t\treturn %s{}, fmt.Errorf(\"email cannot be empty\")\n\t}\n", typeName))
		buf.WriteString("\titems, err := c.Where(onyx.Eq(\"email\", email)).Limit(1).List(ctx)\n")
		buf.WriteString(fmt.Sprintf("\tif err != nil {\n\t\treturn %s{}, fmt.Errorf(%q, email, err)\n\t}\n", typeName, fmt.Sprintf("failed to find %s by email %%s: %%w", typeLabel)))
		buf.WriteString(fmt.Sprintf("\tif len(items) == 0 {\n\t\treturn %s{}, nil\n\t}\n\treturn items[0], nil\n}\n\n", typeName))
	}
	if hasActive {
		buf.WriteString(fmt.Sprintf("func (c %s) FindActiveUsers(ctx context.Context) ([]%s, error) {\n", resourceName, typeName))
		buf.WriteString("\titems, err := c.Where(onyx.Eq(\"isActive\", true)).List(ctx)\n")
		buf.WriteString(fmt.Sprintf("\tif err != nil {\n\t\treturn nil, fmt.Errorf(%q, err)\n\t}\n\treturn items, nil\n}\n\n", fmt.Sprintf("failed to list active %s: %%w", typeLabel)))

		buf.WriteString(fmt.Sprintf("func (c %s) CountActive(ctx context.Context) (int, error) {\n", resourceName))
		buf.WriteString("\tres, err := c.Where(onyx.Eq(\"isActive\", true)).Select(\"count(id)\").List(ctx)\n")
		buf.WriteString(fmt.Sprintf("\tif err != nil {\n\t\treturn 0, fmt.Errorf(%q, err)\n\t}\n", fmt.Sprintf("failed to count active %s: %%w", typeLabel)))
		buf.WriteString("\tif len(res) == 0 {\n\t\treturn 0, nil\n\t}\n")
		buf.WriteString("\tcount, err := parseCount(res[0][\"count(id)\"])\n")
		buf.WriteString(fmt.Sprintf("\tif err != nil {\n\t\treturn 0, fmt.Errorf(%q, err)\n\t}\n\treturn count, nil\n}\n\n", fmt.Sprintf("failed to parse active %s count: %%w", typeLabel)))
	}

	fmt.Fprintf(&buf, "func (c %s) Where(cond onyx.Condition) %s { c.q = c.q.Where(cond); return c }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) And(cond onyx.Condition) %s { c.q = c.q.And(cond); return c }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) Or(cond onyx.Condition) %s { c.q = c.q.Or(cond); return c }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) Resolve(resolvers ...string) %s { c.q = c.q.Resolve(resolvers...); return c }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) OrderBy(field string, asc bool) %s {\n\tif asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }\n\treturn c\n}\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) Limit(n int) %s { c.q = c.q.Limit(n); return c }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) SetUpdates(updates map[string]any) %s { c.q = c.q.SetUpdates(updates); return c }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) Select(fields ...string) %s { c.q = c.q.Select(fields...); return c }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) GroupBy(fields ...string) %s { c.q = c.q.GroupBy(fields...); return c }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) WithTimeout(d time.Duration) %s {\n\tif d <= 0 {\n\t\tc.timeout = 30 * time.Second\n\t\treturn c\n\t}\n\tc.timeout = d\n\treturn c\n}\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) WithDefaultTimeout() %s { return c.WithTimeout(30 * time.Second) }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) WithShortTimeout() %s { return c.WithTimeout(5 * time.Second) }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) WithLongTimeout() %s { return c.WithTimeout(2 * time.Minute) }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) WithHook(h QueryHook) %s { c.hook = h; return c }\n", mapResourceName, mapResourceName)
	fmt.Fprintf(&buf, "func (c %s) Stream(ctx context.Context) (onyx.Iterator, error) {\n\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"stream\", Tables.%s)\n\titer, err := c.q.Stream(ctx)\n\tdone(err)\n\treturn iter, err\n}\n", mapResourceName, typeName)
	fmt.Fprintf(&buf, "func (c %s) List(ctx context.Context) ([]map[string]any, error) {\n\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"list_maps\", Tables.%s)\n\tres := onyx.List(ctx, c.q)\n\tvar out []map[string]any\n\terr := res.Decode(&out)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to decode %s map list: %%w\", err)\n\t\tdone(err)\n\t\treturn nil, err\n\t}\n\tdone(nil)\n\treturn out, nil\n}\n\n", mapResourceName, typeName, typeLabel)
	fmt.Fprintf(&buf, "func (c %s) Page(ctx context.Context, cursor string) (%s, error) {\n", mapResourceName, pageMapName)
	fmt.Fprintf(&buf, "\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"page\", Tables.%s)\n", typeName)
	fmt.Fprintf(&buf, "\tres, err := c.q.Page(ctx, cursor)\n")
	fmt.Fprintf(&buf, "\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to page %s maps: %%w\", err)\n\t\tdone(err)\n\t\treturn %s{}, err\n\t}\n", typeLabel, pageMapName)
	fmt.Fprintf(&buf, "\tif res.Items == nil {\n\t\tdone(nil)\n\t\treturn %s{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil\n\t}\n", pageMapName)
	fmt.Fprintf(&buf, "\tdone(nil)\n\treturn %s{Items: res.Items, NextCursor: res.NextCursor}, nil\n}\n\n", pageMapName)
	fmt.Fprintf(&buf, "func (c %s) Pages(ctx context.Context) *%s { return &%s{client: c, ctx: ctx} }\n\n", mapResourceName, pageMapIterName, pageMapIterName)
	fmt.Fprintf(&buf, "func (c %s) Update(ctx context.Context) (int, error) {\n\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"update\", Tables.%s)\n\tn, err := c.q.Update(ctx)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to update %s maps: %%w\", err)\n\t\tdone(err)\n\t\treturn 0, err\n\t}\n\tdone(nil)\n\treturn n, nil\n}\n\n", mapResourceName, typeName, typeLabel)
	fmt.Fprintf(&buf, "func (c %s) Delete(ctx context.Context) (int, error) {\n\tctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"delete\", Tables.%s)\n\tn, err := c.q.Delete(ctx)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to delete %s maps: %%w\", err)\n\t\tdone(err)\n\t\treturn 0, err\n\t}\n\tdone(nil)\n\treturn n, nil\n}\n\n", mapResourceName, typeName, typeLabel)

	fmt.Fprintf(&buf, "func (it *%s) Next() bool {\n\tif it.err != nil {\n\t\treturn false\n\t}\n\tif !it.started {\n\t\tit.started = true\n\t\tit.err = it.fetch(\"\")\n\t\treturn it.err == nil\n\t}\n\tif it.page.NextCursor == \"\" {\n\t\treturn false\n\t}\n\tit.err = it.fetch(it.page.NextCursor)\n\treturn it.err == nil\n}\n\n", pageIterName)
	fmt.Fprintf(&buf, "func (it *%s) Page() (%s, error) {\n\tif it.err != nil {\n\t\treturn %s{}, it.err\n\t}\n\treturn it.page, nil\n}\n\n", pageIterName, pageName, pageName)
	fmt.Fprintf(&buf, "func (it *%s) Err() error { return it.err }\n\n", pageIterName)
	fmt.Fprintf(&buf, "func (it *%s) fetch(cursor string) error {\n", pageIterName)
	fmt.Fprintf(&buf, "\tctx := it.ctx\n\tclient := it.client\n\tctx, done := withContextAndHook(ctx, client.timeout, client.hook, \"page\", Tables.%s)\n", typeName)
	fmt.Fprintf(&buf, "\tres, err := client.q.Page(ctx, cursor)\n")
	fmt.Fprintf(&buf, "\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to page %s: %%w\", err)\n\t\tdone(err)\n\t\treturn err\n\t}\n", typeLabel)
	fmt.Fprintf(&buf, "\tif res.Items == nil {\n\t\tit.page = %s{Items: []%s{}, NextCursor: res.NextCursor}\n\t\tdone(nil)\n\t\treturn nil\n\t}\n", pageName, typeName)
	fmt.Fprintf(&buf, "\tvar items []%s\n", typeName)
	fmt.Fprintf(&buf, "\tif err := decodeList(res.Items, &items); err != nil {\n\t\terr = fmt.Errorf(\"failed to decode %s page: %%w\", err)\n\t\tdone(err)\n\t\treturn err\n\t}\n", typeLabel)
	fmt.Fprintf(&buf, "\tit.page = %s{Items: items, NextCursor: res.NextCursor}\n\tdone(nil)\n\treturn nil\n}\n\n", pageName)

	fmt.Fprintf(&buf, "func (it *%s) Next() bool {\n\tif it.err != nil {\n\t\treturn false\n\t}\n\tif !it.started {\n\t\tit.started = true\n\t\tit.err = it.fetch(\"\")\n\t\treturn it.err == nil\n\t}\n\tif it.page.NextCursor == \"\" {\n\t\treturn false\n\t}\n\tit.err = it.fetch(it.page.NextCursor)\n\treturn it.err == nil\n}\n\n", pageMapIterName)
	fmt.Fprintf(&buf, "func (it *%s) Page() (%s, error) {\n\tif it.err != nil {\n\t\treturn %s{}, it.err\n\t}\n\treturn it.page, nil\n}\n\n", pageMapIterName, pageMapName, pageMapName)
	fmt.Fprintf(&buf, "func (it *%s) Err() error { return it.err }\n\n", pageMapIterName)
	fmt.Fprintf(&buf, "func (it *%s) fetch(cursor string) error {\n", pageMapIterName)
	fmt.Fprintf(&buf, "\tctx := it.ctx\n\tclient := it.client\n\tctx, done := withContextAndHook(ctx, client.timeout, client.hook, \"page\", Tables.%s)\n", typeName)
	fmt.Fprintf(&buf, "\tres, err := client.q.Page(ctx, cursor)\n")
	fmt.Fprintf(&buf, "\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to page %s maps: %%w\", err)\n\t\tdone(err)\n\t\treturn err\n\t}\n", typeLabel)
	fmt.Fprintf(&buf, "\tif res.Items == nil {\n\t\tit.page = %s{Items: []map[string]any{}, NextCursor: res.NextCursor}\n\t\tdone(nil)\n\t\treturn nil\n\t}\n", pageMapName)
	fmt.Fprintf(&buf, "\tit.page = %s{Items: res.Items, NextCursor: res.NextCursor}\n\tdone(nil)\n\treturn nil\n}\n\n", pageMapName)

	return buf.Bytes()
}

func toExported(name string) string {
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsDigit(r)
	})
	var b strings.Builder
	for _, p := range parts {
		if p == "" {
			continue
		}
		r, size := utf8.DecodeRuneInString(p)
		b.WriteRune(unicode.ToUpper(r))
		b.WriteString(p[size:])
	}
	if b.Len() == 0 {
		return "Name"
	}
	return b.String()
}

func mapFieldType(f onyx.Field, timestampFormat string) string {
	kind := strings.ToLower(strings.TrimSpace(f.Type))
	switch kind {
	case "string":
		if f.Nullable {
			return "*string"
		}
		return "string"
	case "boolean", "bool":
		if f.Nullable {
			return "*bool"
		}
		return "bool"
	case "int", "integer":
		if f.Nullable {
			return "*int64"
		}
		return "int64"
	case "timestamp", "datetime", "date", "time":
		if strings.ToLower(timestampFormat) == "string" {
			if f.Nullable {
				return "*string"
			}
			return "string"
		}
		if f.Nullable {
			return "*time.Time"
		}
		return "time.Time"
	case "embeddedobject", "object", "json", "map", "any":
		return "map[string]any"
	default:
		return "any"
	}
}

func needsTimeTable(table onyx.Table, timestampFormat string) bool {
	if strings.ToLower(timestampFormat) == "string" {
		return false
	}
	for _, f := range table.Fields {
		kind := strings.ToLower(strings.TrimSpace(f.Type))
		if kind == "timestamp" || kind == "datetime" || kind == "date" || kind == "time" {
			return true
		}
	}
	return false
}

func hasField(table onyx.Table, name string) bool {
	for _, f := range table.Fields {
		if strings.EqualFold(strings.TrimSpace(f.Name), strings.TrimSpace(name)) {
			return true
		}
	}
	return false
}

func requiredStringFields(table onyx.Table) []onyx.Field {
	var out []onyx.Field
	for _, f := range table.Fields {
		if strings.EqualFold(strings.TrimSpace(f.Name), "id") {
			continue
		}
		kind := strings.ToLower(strings.TrimSpace(f.Type))
		if (kind == "string") && !f.Nullable {
			out = append(out, f)
		}
	}
	return out
}

func hasResolvers(schema onyx.Schema) bool {
	for _, t := range schema.Tables {
		if len(t.Resolvers) > 0 {
			return true
		}
	}
	return false
}

func toPlural(name string) string {
	if strings.HasSuffix(name, "s") {
		return name
	}
	return name + "s"
}

func toFileName(name string) string {
	var b strings.Builder
	for _, r := range strings.ToLower(name) {
		if unicode.IsLetter(r) || unicode.IsDigit(r) {
			b.WriteRune(r)
			continue
		}
		b.WriteRune('_')
	}
	if b.Len() == 0 {
		return "table"
	}
	return b.String()
}

func clientOutPath(outDir string) string {
	return filepath.Join(outDir, "common.go")
}

// ClientPathFor exposes the client path calculation for external callers.
func ClientPathFor(outDir string) string {
	return clientOutPath(outDir)
}

func renderGenerate(opts Options) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by onyx-gen-go; DO NOT EDIT.\n")
	buf.WriteString("// Generated at: " + generatedTimestamp() + "\n\n")
	buf.WriteString("package " + opts.PackageName + "\n\n")

	relSchema := opts.SchemaPath
	if rel, err := filepath.Rel(opts.OutPath, opts.SchemaPath); err == nil && rel != "" {
		relSchema = rel
	}

	buf.WriteString("//go:generate onyx-go gen")
	if opts.Source != "" {
		buf.WriteString(fmt.Sprintf(" --source %s", opts.Source))
	}
	if relSchema != "" {
		buf.WriteString(fmt.Sprintf(" --schema %s", relSchema))
	}
	if opts.Source == "api" && opts.DatabaseID != "" {
		buf.WriteString(fmt.Sprintf(" --database-id %s", opts.DatabaseID))
	}
	buf.WriteString(" --out .")
	if opts.PackageName != "" {
		buf.WriteString(fmt.Sprintf(" --package %s", opts.PackageName))
	}
	if opts.TimestampFormat != "" && opts.TimestampFormat != "time" {
		buf.WriteString(fmt.Sprintf(" --timestamps %s", opts.TimestampFormat))
	}
	if len(opts.Tables) > 0 {
		buf.WriteString(" --tables ")
		buf.WriteString(strings.Join(opts.Tables, ","))
	}
	buf.WriteString("\n")

	return buf.Bytes()
}

func generatedTimestamp() string {
	if ts := os.Getenv("ONYX_GEN_TIMESTAMP"); strings.TrimSpace(ts) != "" {
		return strings.TrimSpace(ts)
	}
	return time.Now().UTC().Format(time.RFC3339)
}
