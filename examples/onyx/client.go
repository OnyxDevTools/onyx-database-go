// Code generated by onyx-gen-go; DO NOT EDIT.

package onyx

import (
	"context"
	"encoding/json"
	"github.com/OnyxDevTools/onyx-database-go/core"
)

type Client struct{ core core.Client }

func NewClient(core core.Client) Client { return Client{core: core} }

func (c Client) Core() core.Client { return c.core }

type AuditLogQuery struct{ q core.Query }

func (q AuditLogQuery) Where(cond core.Condition) AuditLogQuery { q.q = q.q.Where(cond); return q }
func (q AuditLogQuery) And(cond core.Condition) AuditLogQuery   { q.q = q.q.And(cond); return q }
func (q AuditLogQuery) Or(cond core.Condition) AuditLogQuery    { q.q = q.q.Or(cond); return q }
func (q AuditLogQuery) Resolve(resolvers ...string) AuditLogQuery {
	q.q = q.q.Resolve(resolvers...)
	return q
}
func (q AuditLogQuery) OrderBy(field string, asc bool) AuditLogQuery {
	if asc {
		q.q = q.q.OrderBy(core.Asc(field))
	} else {
		q.q = q.q.OrderBy(core.Desc(field))
	}
	return q
}
func (q AuditLogQuery) Limit(n int) AuditLogQuery             { q.q = q.q.Limit(n); return q }
func (q AuditLogQuery) Select(fields ...string) AuditLogQuery { q.q = q.q.Select(fields...); return q }
func (q AuditLogQuery) GroupBy(fields ...string) AuditLogQuery {
	q.q = q.q.GroupBy(fields...)
	return q
}
func (q AuditLogQuery) List(ctx context.Context) ([]AuditLog, error) {
	res := core.List(ctx, q.q)
	var out []AuditLog
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q AuditLogQuery) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q AuditLogQuery) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c Client) ListAuditLogs() AuditLogQuery {
	return AuditLogQuery{q: c.core.From(Tables.AuditLog)}
}

type AuditLogDelete struct {
	q   core.Query
	ctx context.Context
}

func (d AuditLogDelete) Where(cond core.Condition) AuditLogDelete { d.q = d.q.Where(cond); return d }
func (d AuditLogDelete) And(cond core.Condition) AuditLogDelete   { d.q = d.q.And(cond); return d }
func (d AuditLogDelete) Or(cond core.Condition) AuditLogDelete    { d.q = d.q.Or(cond); return d }
func (d AuditLogDelete) Resolve(resolvers ...string) AuditLogDelete {
	d.q = d.q.Resolve(resolvers...)
	return d
}
func (d AuditLogDelete) Limit(n int) AuditLogDelete { d.q = d.q.Limit(n); return d }
func (d AuditLogDelete) Delete() (int, error)       { return d.q.Delete(d.ctx) }

func (c Client) DeleteAuditLogs(ctx context.Context) AuditLogDelete {
	return AuditLogDelete{q: c.core.From(Tables.AuditLog), ctx: ctx}
}

func (c Client) SaveAuditLog(ctx context.Context, item AuditLog, relationships ...string) (AuditLog, error) {
	saved, err := c.core.Save(ctx, Tables.AuditLog, item, relationships)
	if err != nil {
		return AuditLog{}, err
	}
	var out AuditLog
	if err := decodeSaved(saved, &out); err != nil {
		return AuditLog{}, err
	}
	return out, nil
}

func (c Client) DeleteAuditLog(ctx context.Context, id string) (int, error) {
	if err := c.core.Delete(ctx, Tables.AuditLog, id); err != nil {
		return 0, err
	}
	return 1, nil
}

type PermissionQuery struct{ q core.Query }

func (q PermissionQuery) Where(cond core.Condition) PermissionQuery { q.q = q.q.Where(cond); return q }
func (q PermissionQuery) And(cond core.Condition) PermissionQuery   { q.q = q.q.And(cond); return q }
func (q PermissionQuery) Or(cond core.Condition) PermissionQuery    { q.q = q.q.Or(cond); return q }
func (q PermissionQuery) Resolve(resolvers ...string) PermissionQuery {
	q.q = q.q.Resolve(resolvers...)
	return q
}
func (q PermissionQuery) OrderBy(field string, asc bool) PermissionQuery {
	if asc {
		q.q = q.q.OrderBy(core.Asc(field))
	} else {
		q.q = q.q.OrderBy(core.Desc(field))
	}
	return q
}
func (q PermissionQuery) Limit(n int) PermissionQuery { q.q = q.q.Limit(n); return q }
func (q PermissionQuery) Select(fields ...string) PermissionQuery {
	q.q = q.q.Select(fields...)
	return q
}
func (q PermissionQuery) GroupBy(fields ...string) PermissionQuery {
	q.q = q.q.GroupBy(fields...)
	return q
}
func (q PermissionQuery) List(ctx context.Context) ([]Permission, error) {
	res := core.List(ctx, q.q)
	var out []Permission
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q PermissionQuery) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q PermissionQuery) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c Client) ListPermissions() PermissionQuery {
	return PermissionQuery{q: c.core.From(Tables.Permission)}
}

type PermissionDelete struct {
	q   core.Query
	ctx context.Context
}

func (d PermissionDelete) Where(cond core.Condition) PermissionDelete {
	d.q = d.q.Where(cond)
	return d
}
func (d PermissionDelete) And(cond core.Condition) PermissionDelete { d.q = d.q.And(cond); return d }
func (d PermissionDelete) Or(cond core.Condition) PermissionDelete  { d.q = d.q.Or(cond); return d }
func (d PermissionDelete) Resolve(resolvers ...string) PermissionDelete {
	d.q = d.q.Resolve(resolvers...)
	return d
}
func (d PermissionDelete) Limit(n int) PermissionDelete { d.q = d.q.Limit(n); return d }
func (d PermissionDelete) Delete() (int, error)         { return d.q.Delete(d.ctx) }

func (c Client) DeletePermissions(ctx context.Context) PermissionDelete {
	return PermissionDelete{q: c.core.From(Tables.Permission), ctx: ctx}
}

func (c Client) SavePermission(ctx context.Context, item Permission, relationships ...string) (Permission, error) {
	saved, err := c.core.Save(ctx, Tables.Permission, item, relationships)
	if err != nil {
		return Permission{}, err
	}
	var out Permission
	if err := decodeSaved(saved, &out); err != nil {
		return Permission{}, err
	}
	return out, nil
}

func (c Client) DeletePermission(ctx context.Context, id string) (int, error) {
	if err := c.core.Delete(ctx, Tables.Permission, id); err != nil {
		return 0, err
	}
	return 1, nil
}

type RoleQuery struct{ q core.Query }

func (q RoleQuery) Where(cond core.Condition) RoleQuery   { q.q = q.q.Where(cond); return q }
func (q RoleQuery) And(cond core.Condition) RoleQuery     { q.q = q.q.And(cond); return q }
func (q RoleQuery) Or(cond core.Condition) RoleQuery      { q.q = q.q.Or(cond); return q }
func (q RoleQuery) Resolve(resolvers ...string) RoleQuery { q.q = q.q.Resolve(resolvers...); return q }
func (q RoleQuery) OrderBy(field string, asc bool) RoleQuery {
	if asc {
		q.q = q.q.OrderBy(core.Asc(field))
	} else {
		q.q = q.q.OrderBy(core.Desc(field))
	}
	return q
}
func (q RoleQuery) Limit(n int) RoleQuery              { q.q = q.q.Limit(n); return q }
func (q RoleQuery) Select(fields ...string) RoleQuery  { q.q = q.q.Select(fields...); return q }
func (q RoleQuery) GroupBy(fields ...string) RoleQuery { q.q = q.q.GroupBy(fields...); return q }
func (q RoleQuery) List(ctx context.Context) ([]Role, error) {
	res := core.List(ctx, q.q)
	var out []Role
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q RoleQuery) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q RoleQuery) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c Client) ListRoles() RoleQuery {
	return RoleQuery{q: c.core.From(Tables.Role)}
}

type RoleDelete struct {
	q   core.Query
	ctx context.Context
}

func (d RoleDelete) Where(cond core.Condition) RoleDelete { d.q = d.q.Where(cond); return d }
func (d RoleDelete) And(cond core.Condition) RoleDelete   { d.q = d.q.And(cond); return d }
func (d RoleDelete) Or(cond core.Condition) RoleDelete    { d.q = d.q.Or(cond); return d }
func (d RoleDelete) Resolve(resolvers ...string) RoleDelete {
	d.q = d.q.Resolve(resolvers...)
	return d
}
func (d RoleDelete) Limit(n int) RoleDelete { d.q = d.q.Limit(n); return d }
func (d RoleDelete) Delete() (int, error)   { return d.q.Delete(d.ctx) }

func (c Client) DeleteRoles(ctx context.Context) RoleDelete {
	return RoleDelete{q: c.core.From(Tables.Role), ctx: ctx}
}

func (c Client) SaveRole(ctx context.Context, item Role, relationships ...string) (Role, error) {
	saved, err := c.core.Save(ctx, Tables.Role, item, relationships)
	if err != nil {
		return Role{}, err
	}
	var out Role
	if err := decodeSaved(saved, &out); err != nil {
		return Role{}, err
	}
	return out, nil
}

func (c Client) DeleteRole(ctx context.Context, id string) (int, error) {
	if err := c.core.Delete(ctx, Tables.Role, id); err != nil {
		return 0, err
	}
	return 1, nil
}

type RolePermissionQuery struct{ q core.Query }

func (q RolePermissionQuery) Where(cond core.Condition) RolePermissionQuery {
	q.q = q.q.Where(cond)
	return q
}
func (q RolePermissionQuery) And(cond core.Condition) RolePermissionQuery {
	q.q = q.q.And(cond)
	return q
}
func (q RolePermissionQuery) Or(cond core.Condition) RolePermissionQuery {
	q.q = q.q.Or(cond)
	return q
}
func (q RolePermissionQuery) Resolve(resolvers ...string) RolePermissionQuery {
	q.q = q.q.Resolve(resolvers...)
	return q
}
func (q RolePermissionQuery) OrderBy(field string, asc bool) RolePermissionQuery {
	if asc {
		q.q = q.q.OrderBy(core.Asc(field))
	} else {
		q.q = q.q.OrderBy(core.Desc(field))
	}
	return q
}
func (q RolePermissionQuery) Limit(n int) RolePermissionQuery { q.q = q.q.Limit(n); return q }
func (q RolePermissionQuery) Select(fields ...string) RolePermissionQuery {
	q.q = q.q.Select(fields...)
	return q
}
func (q RolePermissionQuery) GroupBy(fields ...string) RolePermissionQuery {
	q.q = q.q.GroupBy(fields...)
	return q
}
func (q RolePermissionQuery) List(ctx context.Context) ([]RolePermission, error) {
	res := core.List(ctx, q.q)
	var out []RolePermission
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q RolePermissionQuery) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q RolePermissionQuery) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c Client) ListRolePermissions() RolePermissionQuery {
	return RolePermissionQuery{q: c.core.From(Tables.RolePermission)}
}

type RolePermissionDelete struct {
	q   core.Query
	ctx context.Context
}

func (d RolePermissionDelete) Where(cond core.Condition) RolePermissionDelete {
	d.q = d.q.Where(cond)
	return d
}
func (d RolePermissionDelete) And(cond core.Condition) RolePermissionDelete {
	d.q = d.q.And(cond)
	return d
}
func (d RolePermissionDelete) Or(cond core.Condition) RolePermissionDelete {
	d.q = d.q.Or(cond)
	return d
}
func (d RolePermissionDelete) Resolve(resolvers ...string) RolePermissionDelete {
	d.q = d.q.Resolve(resolvers...)
	return d
}
func (d RolePermissionDelete) Limit(n int) RolePermissionDelete { d.q = d.q.Limit(n); return d }
func (d RolePermissionDelete) Delete() (int, error)             { return d.q.Delete(d.ctx) }

func (c Client) DeleteRolePermissions(ctx context.Context) RolePermissionDelete {
	return RolePermissionDelete{q: c.core.From(Tables.RolePermission), ctx: ctx}
}

func (c Client) SaveRolePermission(ctx context.Context, item RolePermission, relationships ...string) (RolePermission, error) {
	saved, err := c.core.Save(ctx, Tables.RolePermission, item, relationships)
	if err != nil {
		return RolePermission{}, err
	}
	var out RolePermission
	if err := decodeSaved(saved, &out); err != nil {
		return RolePermission{}, err
	}
	return out, nil
}

func (c Client) DeleteRolePermission(ctx context.Context, id string) (int, error) {
	if err := c.core.Delete(ctx, Tables.RolePermission, id); err != nil {
		return 0, err
	}
	return 1, nil
}

type UserQuery struct{ q core.Query }

func (q UserQuery) Where(cond core.Condition) UserQuery   { q.q = q.q.Where(cond); return q }
func (q UserQuery) And(cond core.Condition) UserQuery     { q.q = q.q.And(cond); return q }
func (q UserQuery) Or(cond core.Condition) UserQuery      { q.q = q.q.Or(cond); return q }
func (q UserQuery) Resolve(resolvers ...string) UserQuery { q.q = q.q.Resolve(resolvers...); return q }
func (q UserQuery) OrderBy(field string, asc bool) UserQuery {
	if asc {
		q.q = q.q.OrderBy(core.Asc(field))
	} else {
		q.q = q.q.OrderBy(core.Desc(field))
	}
	return q
}
func (q UserQuery) Limit(n int) UserQuery              { q.q = q.q.Limit(n); return q }
func (q UserQuery) Select(fields ...string) UserQuery  { q.q = q.q.Select(fields...); return q }
func (q UserQuery) GroupBy(fields ...string) UserQuery { q.q = q.q.GroupBy(fields...); return q }
func (q UserQuery) List(ctx context.Context) ([]User, error) {
	res := core.List(ctx, q.q)
	var out []User
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q UserQuery) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q UserQuery) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c Client) ListUsers() UserQuery {
	return UserQuery{q: c.core.From(Tables.User)}
}

type UserDelete struct {
	q   core.Query
	ctx context.Context
}

func (d UserDelete) Where(cond core.Condition) UserDelete { d.q = d.q.Where(cond); return d }
func (d UserDelete) And(cond core.Condition) UserDelete   { d.q = d.q.And(cond); return d }
func (d UserDelete) Or(cond core.Condition) UserDelete    { d.q = d.q.Or(cond); return d }
func (d UserDelete) Resolve(resolvers ...string) UserDelete {
	d.q = d.q.Resolve(resolvers...)
	return d
}
func (d UserDelete) Limit(n int) UserDelete { d.q = d.q.Limit(n); return d }
func (d UserDelete) Delete() (int, error)   { return d.q.Delete(d.ctx) }

func (c Client) DeleteUsers(ctx context.Context) UserDelete {
	return UserDelete{q: c.core.From(Tables.User), ctx: ctx}
}

func (c Client) SaveUser(ctx context.Context, item User, relationships ...string) (User, error) {
	saved, err := c.core.Save(ctx, Tables.User, item, relationships)
	if err != nil {
		return User{}, err
	}
	var out User
	if err := decodeSaved(saved, &out); err != nil {
		return User{}, err
	}
	return out, nil
}

func (c Client) DeleteUser(ctx context.Context, id string) (int, error) {
	if err := c.core.Delete(ctx, Tables.User, id); err != nil {
		return 0, err
	}
	return 1, nil
}

type UserProfileQuery struct{ q core.Query }

func (q UserProfileQuery) Where(cond core.Condition) UserProfileQuery {
	q.q = q.q.Where(cond)
	return q
}
func (q UserProfileQuery) And(cond core.Condition) UserProfileQuery { q.q = q.q.And(cond); return q }
func (q UserProfileQuery) Or(cond core.Condition) UserProfileQuery  { q.q = q.q.Or(cond); return q }
func (q UserProfileQuery) Resolve(resolvers ...string) UserProfileQuery {
	q.q = q.q.Resolve(resolvers...)
	return q
}
func (q UserProfileQuery) OrderBy(field string, asc bool) UserProfileQuery {
	if asc {
		q.q = q.q.OrderBy(core.Asc(field))
	} else {
		q.q = q.q.OrderBy(core.Desc(field))
	}
	return q
}
func (q UserProfileQuery) Limit(n int) UserProfileQuery { q.q = q.q.Limit(n); return q }
func (q UserProfileQuery) Select(fields ...string) UserProfileQuery {
	q.q = q.q.Select(fields...)
	return q
}
func (q UserProfileQuery) GroupBy(fields ...string) UserProfileQuery {
	q.q = q.q.GroupBy(fields...)
	return q
}
func (q UserProfileQuery) List(ctx context.Context) ([]UserProfile, error) {
	res := core.List(ctx, q.q)
	var out []UserProfile
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q UserProfileQuery) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q UserProfileQuery) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c Client) ListUserProfiles() UserProfileQuery {
	return UserProfileQuery{q: c.core.From(Tables.UserProfile)}
}

type UserProfileDelete struct {
	q   core.Query
	ctx context.Context
}

func (d UserProfileDelete) Where(cond core.Condition) UserProfileDelete {
	d.q = d.q.Where(cond)
	return d
}
func (d UserProfileDelete) And(cond core.Condition) UserProfileDelete { d.q = d.q.And(cond); return d }
func (d UserProfileDelete) Or(cond core.Condition) UserProfileDelete  { d.q = d.q.Or(cond); return d }
func (d UserProfileDelete) Resolve(resolvers ...string) UserProfileDelete {
	d.q = d.q.Resolve(resolvers...)
	return d
}
func (d UserProfileDelete) Limit(n int) UserProfileDelete { d.q = d.q.Limit(n); return d }
func (d UserProfileDelete) Delete() (int, error)          { return d.q.Delete(d.ctx) }

func (c Client) DeleteUserProfiles(ctx context.Context) UserProfileDelete {
	return UserProfileDelete{q: c.core.From(Tables.UserProfile), ctx: ctx}
}

func (c Client) SaveUserProfile(ctx context.Context, item UserProfile, relationships ...string) (UserProfile, error) {
	saved, err := c.core.Save(ctx, Tables.UserProfile, item, relationships)
	if err != nil {
		return UserProfile{}, err
	}
	var out UserProfile
	if err := decodeSaved(saved, &out); err != nil {
		return UserProfile{}, err
	}
	return out, nil
}

func (c Client) DeleteUserProfile(ctx context.Context, id string) (int, error) {
	if err := c.core.Delete(ctx, Tables.UserProfile, id); err != nil {
		return 0, err
	}
	return 1, nil
}

type UserRoleQuery struct{ q core.Query }

func (q UserRoleQuery) Where(cond core.Condition) UserRoleQuery { q.q = q.q.Where(cond); return q }
func (q UserRoleQuery) And(cond core.Condition) UserRoleQuery   { q.q = q.q.And(cond); return q }
func (q UserRoleQuery) Or(cond core.Condition) UserRoleQuery    { q.q = q.q.Or(cond); return q }
func (q UserRoleQuery) Resolve(resolvers ...string) UserRoleQuery {
	q.q = q.q.Resolve(resolvers...)
	return q
}
func (q UserRoleQuery) OrderBy(field string, asc bool) UserRoleQuery {
	if asc {
		q.q = q.q.OrderBy(core.Asc(field))
	} else {
		q.q = q.q.OrderBy(core.Desc(field))
	}
	return q
}
func (q UserRoleQuery) Limit(n int) UserRoleQuery             { q.q = q.q.Limit(n); return q }
func (q UserRoleQuery) Select(fields ...string) UserRoleQuery { q.q = q.q.Select(fields...); return q }
func (q UserRoleQuery) GroupBy(fields ...string) UserRoleQuery {
	q.q = q.q.GroupBy(fields...)
	return q
}
func (q UserRoleQuery) List(ctx context.Context) ([]UserRole, error) {
	res := core.List(ctx, q.q)
	var out []UserRole
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q UserRoleQuery) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (q UserRoleQuery) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	res := core.List(ctx, q.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c Client) ListUserRoles() UserRoleQuery {
	return UserRoleQuery{q: c.core.From(Tables.UserRole)}
}

type UserRoleDelete struct {
	q   core.Query
	ctx context.Context
}

func (d UserRoleDelete) Where(cond core.Condition) UserRoleDelete { d.q = d.q.Where(cond); return d }
func (d UserRoleDelete) And(cond core.Condition) UserRoleDelete   { d.q = d.q.And(cond); return d }
func (d UserRoleDelete) Or(cond core.Condition) UserRoleDelete    { d.q = d.q.Or(cond); return d }
func (d UserRoleDelete) Resolve(resolvers ...string) UserRoleDelete {
	d.q = d.q.Resolve(resolvers...)
	return d
}
func (d UserRoleDelete) Limit(n int) UserRoleDelete { d.q = d.q.Limit(n); return d }
func (d UserRoleDelete) Delete() (int, error)       { return d.q.Delete(d.ctx) }

func (c Client) DeleteUserRoles(ctx context.Context) UserRoleDelete {
	return UserRoleDelete{q: c.core.From(Tables.UserRole), ctx: ctx}
}

func (c Client) SaveUserRole(ctx context.Context, item UserRole, relationships ...string) (UserRole, error) {
	saved, err := c.core.Save(ctx, Tables.UserRole, item, relationships)
	if err != nil {
		return UserRole{}, err
	}
	var out UserRole
	if err := decodeSaved(saved, &out); err != nil {
		return UserRole{}, err
	}
	return out, nil
}

func (c Client) DeleteUserRole(ctx context.Context, id string) (int, error) {
	if err := c.core.Delete(ctx, Tables.UserRole, id); err != nil {
		return 0, err
	}
	return 1, nil
}

func decodeSaved(saved map[string]any, out any) error {
	b, err := json.Marshal(saved)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, out)
}

type DocumentsClient struct{ core core.DocumentClient }

func (c Client) Documents() DocumentsClient { return DocumentsClient{core: c.core.Documents()} }

func (d DocumentsClient) List(ctx context.Context) ([]core.Document, error) { return d.core.List(ctx) }
func (d DocumentsClient) Get(ctx context.Context, id string) (core.Document, error) {
	return d.core.Get(ctx, id)
}
func (d DocumentsClient) Save(ctx context.Context, doc core.Document) (core.Document, error) {
	return d.core.Save(ctx, doc)
}
func (d DocumentsClient) Delete(ctx context.Context, id string) error { return d.core.Delete(ctx, id) }
