// Code generated by onyx-gen-go; DO NOT EDIT.
// Generated at: 2026-01-20T06:44:58Z

package onyx

import (
	"context"
	"time"
	"fmt"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type User struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	Email *string `json:"email,omitempty"`
	Id *string `json:"id,omitempty"`
	IsActive *bool `json:"isActive,omitempty"`
	LastLoginAt *time.Time `json:"lastLoginAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	Username *string `json:"username,omitempty"`
	Profile any `json:"profile,omitempty"`
	Roles any `json:"roles,omitempty"`
	UserRoles any `json:"userRoles,omitempty"`
}

// UserUpdates provides typed setters for update operations on User.
type UserUpdates struct { values map[string]any }

func NewUserUpdates() *UserUpdates { return &UserUpdates{values: make(map[string]any)} }

func (u *UserUpdates) SetCreatedAt(v *time.Time) *UserUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["createdAt"] = v
	return u
}

func (u *UserUpdates) SetDeletedAt(v *time.Time) *UserUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["deletedAt"] = v
	return u
}

func (u *UserUpdates) SetEmail(v *string) *UserUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["email"] = v
	return u
}

func (u *UserUpdates) SetId(v *string) *UserUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["id"] = v
	return u
}

func (u *UserUpdates) SetIsActive(v *bool) *UserUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["isActive"] = v
	return u
}

func (u *UserUpdates) SetLastLoginAt(v *time.Time) *UserUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["lastLoginAt"] = v
	return u
}

func (u *UserUpdates) SetUpdatedAt(v *time.Time) *UserUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["updatedAt"] = v
	return u
}

func (u *UserUpdates) SetUsername(v *string) *UserUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["username"] = v
	return u
}

func (u *UserUpdates) valuesMap() map[string]any { return u.values }

type UserPage struct {
	Items []User `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

// UsersClient provides a fluent API for querying and manipulating User records.
// All methods return a new client instance, allowing for method chaining.
//
// Example:
//   items, err := db.Users().
//       Where(onyx.Eq("isActive", true)).
//       OrderBy("createdAt", false).
//       Limit(10).
//       List(ctx)
type UsersClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }
// UsersMapClient provides map-based query helpers returned from Select/GroupBy operations.
type UsersMapClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }

// UserRepository captures the full set of UsersClient operations for easy mocking in tests.
type UserRepository interface {
	Where(cond onyx.Condition) UsersClient
	And(cond onyx.Condition) UsersClient
	Or(cond onyx.Condition) UsersClient
	Resolve(resolvers ...string) UsersClient
	OrderBy(field string, asc bool) UsersClient
	Limit(n int) UsersClient
	SetUpdates(updates map[string]any) UsersClient
	SetUserUpdates(updates *UserUpdates) UsersClient
	Select(fields ...string) UsersMapClient
	GroupBy(fields ...string) UsersMapClient
	AsMaps() UsersMapClient
	WithTimeout(d time.Duration) UsersClient
	WithDefaultTimeout() UsersClient
	WithShortTimeout() UsersClient
	WithLongTimeout() UsersClient
	WithHook(h QueryHook) UsersClient
	Stream(ctx context.Context) (onyx.Iterator, error)
	List(ctx context.Context) ([]User, error)
	ListMaps(ctx context.Context) ([]map[string]any, error)
	Page(ctx context.Context, cursor string) (UserPage, error)
	Pages(ctx context.Context) *UsersPageIterator
	PageOfMaps(ctx context.Context, cursor string) (UserMapPage, error)
	Update(ctx context.Context) (int, error)
	Delete(ctx context.Context) (int, error)
	Save(ctx context.Context, item User, cascades ...onyx.CascadeSpec) (User, error)
	SaveMany(ctx context.Context, items []User, cascades ...onyx.CascadeSpec) ([]User, error)
	DeleteByID(ctx context.Context, id string) (int, error)
	DeleteByIDs(ctx context.Context, ids []string) (int, error)
	FindByID(ctx context.Context, id string) (User, error)
	FindByEmail(ctx context.Context, email string) (User, error)
	FindActiveUsers(ctx context.Context) ([]User, error)
	CountActive(ctx context.Context) (int, error)
}

// UsersPageIterator iterates over paginated User results.
type UsersPageIterator struct {
	client UsersClient
	ctx context.Context
	cursor string
	started bool
	page UserPage
	err error
}

// UsersMapPageIterator iterates over paginated map results for User queries.
type UsersMapPageIterator struct {
	client UsersMapClient
	ctx context.Context
	cursor string
	started bool
	page UserMapPage
	err error
}

// Users returns a typed client scoped to the User table.
func (c DB) Users() UsersClient { return UsersClient{core: c.core, q: c.core.From(Tables.User)} }

func (c UsersClient) Where(cond onyx.Condition) UsersClient { c.q = c.q.Where(cond); return c }
func (c UsersClient) And(cond onyx.Condition) UsersClient { c.q = c.q.And(cond); return c }
func (c UsersClient) Or(cond onyx.Condition) UsersClient { c.q = c.q.Or(cond); return c }
func (c UsersClient) Resolve(resolvers ...string) UsersClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UsersClient) OrderBy(field string, asc bool) UsersClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UsersClient) Limit(n int) UsersClient { c.q = c.q.Limit(n); return c }
func (c UsersClient) SetUpdates(updates map[string]any) UsersClient { c.q = c.q.SetUpdates(updates); return c }
func (c UsersClient) SetUserUpdates(updates *UserUpdates) UsersClient {
	if updates == nil {
		return c
	}
	c.q = c.q.SetUpdates(updates.valuesMap())
	return c
}
func (c UsersClient) Select(fields ...string) UsersMapClient {
	c.q = c.q.Select(fields...)
	return UsersMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c UsersClient) GroupBy(fields ...string) UsersMapClient {
	c.q = c.q.GroupBy(fields...)
	return UsersMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c UsersClient) AsMaps() UsersMapClient { return UsersMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c UsersClient) WithTimeout(d time.Duration) UsersClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c UsersClient) WithDefaultTimeout() UsersClient { return c.WithTimeout(30 * time.Second) }
func (c UsersClient) WithShortTimeout() UsersClient { return c.WithTimeout(5 * time.Second) }
func (c UsersClient) WithLongTimeout() UsersClient { return c.WithTimeout(2 * time.Minute) }
func (c UsersClient) WithHook(h QueryHook) UsersClient { c.hook = h; return c }
func (c UsersClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.User)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c UsersClient) List(ctx context.Context) ([]User, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list", Tables.User)
	res := onyx.List(ctx, c.q)
	var out []User
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode User list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c UsersClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.User)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode User map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c UsersClient) Page(ctx context.Context, cursor string) (UserPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.User)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page user: %w", err)
		done(err)
		return UserPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return UserPage{Items: []User{}, NextCursor: res.NextCursor}, nil
	}
	var items []User
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode user page: %w", err)
		done(err)
		return UserPage{}, err
	}
	done(nil)
	return UserPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c UsersClient) Pages(ctx context.Context) *UsersPageIterator { return &UsersPageIterator{client: c, ctx: ctx} }

func (c UsersClient) PageOfMaps(ctx context.Context, cursor string) (UserMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.User)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page user maps: %w", err)
		done(err)
		return UserMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return UserMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return UserMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UsersClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.User)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update User: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UsersClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.User)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete User: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UsersClient) Save(ctx context.Context, item User, cascades ...onyx.CascadeSpec) (User, error) {
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return User{}, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "save", Tables.User)
	saved, err := c.core.Save(ctx, Tables.User, item, relationships)
	if err != nil {
		err = fmt.Errorf("failed to save user: %w", err)
		done(err)
		return User{}, err
	}
	var out User
	if err := decodeSaved(saved, &out); err != nil {
		err = fmt.Errorf("failed to decode saved user: %w", err)
		done(err)
		return User{}, err
	}
	done(nil)
	return out, nil
}

func (c UsersClient) SaveMany(ctx context.Context, items []User, cascades ...onyx.CascadeSpec) ([]User, error) {
	if len(items) == 0 {
		return nil, nil
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return nil, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	out := make([]User, 0, len(items))
	for i, item := range items {
		ctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, "save_many", Tables.User)
		saved, err := c.core.Save(ctxOp, Tables.User, item, relationships)
		if err != nil {
			err = fmt.Errorf("failed to save user at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		var decoded User
		if err := decodeSaved(saved, &decoded); err != nil {
			err = fmt.Errorf("failed to decode saved user at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		done(nil)
		out = append(out, decoded)
	}
	return out, nil
}

func (c UsersClient) DeleteByID(ctx context.Context, id string) (int, error) {
	if id == "" {
		return 0, fmt.Errorf("user id cannot be empty")
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete_by_id", Tables.User)
	err := c.core.Delete(ctx, Tables.User, id)
	if err != nil {
		err = fmt.Errorf("failed to delete user %s: %w", id, err)
		done(err)
		return 0, err
	}
	done(nil)
	return 1, nil
}

func (c UsersClient) DeleteByIDs(ctx context.Context, ids []string) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	for i, id := range ids {
		if id == "" {
			return 0, fmt.Errorf("id at index %d is empty", i)
		}
	}
	client := c.Where(onyx.In("id", toAnyStrings(ids)))
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "delete_many", Tables.User)
	n, err := client.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete user by ids: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UsersClient) FindByID(ctx context.Context, id string) (User, error) {
	if id == "" {
		return User{}, fmt.Errorf("user id cannot be empty")
	}
	items, err := c.Where(onyx.Eq("id", id)).Limit(1).List(ctx)
	if err != nil {
		return User{}, fmt.Errorf("failed to find user by id %s: %w", id, err)
	}
	if len(items) == 0 {
		return User{}, nil
	}
	return items[0], nil
}

func (c UsersClient) FindByEmail(ctx context.Context, email string) (User, error) {
	if email == "" {
		return User{}, fmt.Errorf("email cannot be empty")
	}
	items, err := c.Where(onyx.Eq("email", email)).Limit(1).List(ctx)
	if err != nil {
		return User{}, fmt.Errorf("failed to find user by email %s: %w", email, err)
	}
	if len(items) == 0 {
		return User{}, nil
	}
	return items[0], nil
}

func (c UsersClient) FindActiveUsers(ctx context.Context) ([]User, error) {
	items, err := c.Where(onyx.Eq("isActive", true)).List(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list active user: %w", err)
	}
	return items, nil
}

func (c UsersClient) CountActive(ctx context.Context) (int, error) {
	res, err := c.Where(onyx.Eq("isActive", true)).Select("count(id)").List(ctx)
	if err != nil {
		return 0, fmt.Errorf("failed to count active user: %w", err)
	}
	if len(res) == 0 {
		return 0, nil
	}
	count, err := parseCount(res[0]["count(id)"])
	if err != nil {
		return 0, fmt.Errorf("failed to parse active user count: %w", err)
	}
	return count, nil
}

func (c UsersMapClient) Where(cond onyx.Condition) UsersMapClient { c.q = c.q.Where(cond); return c }
func (c UsersMapClient) And(cond onyx.Condition) UsersMapClient { c.q = c.q.And(cond); return c }
func (c UsersMapClient) Or(cond onyx.Condition) UsersMapClient { c.q = c.q.Or(cond); return c }
func (c UsersMapClient) Resolve(resolvers ...string) UsersMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UsersMapClient) OrderBy(field string, asc bool) UsersMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UsersMapClient) Limit(n int) UsersMapClient { c.q = c.q.Limit(n); return c }
func (c UsersMapClient) SetUpdates(updates map[string]any) UsersMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c UsersMapClient) Select(fields ...string) UsersMapClient { c.q = c.q.Select(fields...); return c }
func (c UsersMapClient) GroupBy(fields ...string) UsersMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c UsersMapClient) WithTimeout(d time.Duration) UsersMapClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c UsersMapClient) WithDefaultTimeout() UsersMapClient { return c.WithTimeout(30 * time.Second) }
func (c UsersMapClient) WithShortTimeout() UsersMapClient { return c.WithTimeout(5 * time.Second) }
func (c UsersMapClient) WithLongTimeout() UsersMapClient { return c.WithTimeout(2 * time.Minute) }
func (c UsersMapClient) WithHook(h QueryHook) UsersMapClient { c.hook = h; return c }
func (c UsersMapClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.User)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c UsersMapClient) List(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.User)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode user map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c UsersMapClient) Page(ctx context.Context, cursor string) (UserMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.User)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page user maps: %w", err)
		done(err)
		return UserMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return UserMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return UserMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UsersMapClient) Pages(ctx context.Context) *UsersMapPageIterator { return &UsersMapPageIterator{client: c, ctx: ctx} }

func (c UsersMapClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.User)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update user maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UsersMapClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.User)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete user maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (it *UsersPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *UsersPageIterator) Page() (UserPage, error) {
	if it.err != nil {
		return UserPage{}, it.err
	}
	return it.page, nil
}

func (it *UsersPageIterator) Err() error { return it.err }

func (it *UsersPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.User)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page user: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = UserPage{Items: []User{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	var items []User
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode user page: %w", err)
		done(err)
		return err
	}
	it.page = UserPage{Items: items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

func (it *UsersMapPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *UsersMapPageIterator) Page() (UserMapPage, error) {
	if it.err != nil {
		return UserMapPage{}, it.err
	}
	return it.page, nil
}

func (it *UsersMapPageIterator) Err() error { return it.err }

func (it *UsersMapPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.User)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page user maps: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = UserMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	it.page = UserMapPage{Items: res.Items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

