// Code generated by onyx-gen-go; DO NOT EDIT.
// Generated at: 2026-01-10T03:17:54Z

package onyx

import (
	"context"
	"time"
	"fmt"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type RolePermission struct {
	CreatedAt time.Time `json:"createdAt,omitempty"`
	Id string `json:"id,omitempty"`
	PermissionId string `json:"permissionId,omitempty"`
	RoleId string `json:"roleId,omitempty"`
	Permission any `json:"permission,omitempty"`
	Role any `json:"role,omitempty"`
}

// RolePermissionUpdates provides typed setters for update operations on RolePermission.
type RolePermissionUpdates struct { values map[string]any }

func NewRolePermissionUpdates() *RolePermissionUpdates { return &RolePermissionUpdates{values: make(map[string]any)} }

func (u *RolePermissionUpdates) SetCreatedAt(v time.Time) *RolePermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["createdAt"] = v
	return u
}

func (u *RolePermissionUpdates) SetId(v string) *RolePermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["id"] = v
	return u
}

func (u *RolePermissionUpdates) SetPermissionId(v string) *RolePermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["permissionId"] = v
	return u
}

func (u *RolePermissionUpdates) SetRoleId(v string) *RolePermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["roleId"] = v
	return u
}

func (u *RolePermissionUpdates) valuesMap() map[string]any { return u.values }

type RolePermissionPage struct {
	Items []RolePermission `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RolePermissionMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

func validateRolePermission(item RolePermission) error {
	if item.PermissionId == "" {
		return fmt.Errorf("rolepermission permissionId is required")
	}
	if item.RoleId == "" {
		return fmt.Errorf("rolepermission roleId is required")
	}
	return nil
}

// RolePermissionsClient provides a fluent API for querying and manipulating RolePermission records.
// All methods return a new client instance, allowing for method chaining.
//
// Example:
//   items, err := db.RolePermissions().
//       Where(onyx.Eq("isActive", true)).
//       OrderBy("createdAt", false).
//       Limit(10).
//       List(ctx)
type RolePermissionsClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }
// RolePermissionsMapClient provides map-based query helpers returned from Select/GroupBy operations.
type RolePermissionsMapClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }

// RolePermissionRepository captures the full set of RolePermissionsClient operations for easy mocking in tests.
type RolePermissionRepository interface {
	Where(cond onyx.Condition) RolePermissionsClient
	And(cond onyx.Condition) RolePermissionsClient
	Or(cond onyx.Condition) RolePermissionsClient
	Resolve(resolvers ...string) RolePermissionsClient
	OrderBy(field string, asc bool) RolePermissionsClient
	Limit(n int) RolePermissionsClient
	SetUpdates(updates map[string]any) RolePermissionsClient
	SetRolePermissionUpdates(updates *RolePermissionUpdates) RolePermissionsClient
	Select(fields ...string) RolePermissionsMapClient
	GroupBy(fields ...string) RolePermissionsMapClient
	AsMaps() RolePermissionsMapClient
	WithTimeout(d time.Duration) RolePermissionsClient
	WithDefaultTimeout() RolePermissionsClient
	WithShortTimeout() RolePermissionsClient
	WithLongTimeout() RolePermissionsClient
	WithHook(h QueryHook) RolePermissionsClient
	Stream(ctx context.Context) (onyx.Iterator, error)
	List(ctx context.Context) ([]RolePermission, error)
	ListMaps(ctx context.Context) ([]map[string]any, error)
	Page(ctx context.Context, cursor string) (RolePermissionPage, error)
	Pages(ctx context.Context) *RolePermissionsPageIterator
	PageOfMaps(ctx context.Context, cursor string) (RolePermissionMapPage, error)
	Update(ctx context.Context) (int, error)
	Delete(ctx context.Context) (int, error)
	Save(ctx context.Context, item RolePermission, cascades ...onyx.CascadeSpec) (RolePermission, error)
	SaveMany(ctx context.Context, items []RolePermission, cascades ...onyx.CascadeSpec) ([]RolePermission, error)
	DeleteByID(ctx context.Context, id string) (int, error)
	DeleteByIDs(ctx context.Context, ids []string) (int, error)
	FindByID(ctx context.Context, id string) (RolePermission, error)
}

// RolePermissionsPageIterator iterates over paginated RolePermission results.
type RolePermissionsPageIterator struct {
	client RolePermissionsClient
	ctx context.Context
	cursor string
	started bool
	page RolePermissionPage
	err error
}

// RolePermissionsMapPageIterator iterates over paginated map results for RolePermission queries.
type RolePermissionsMapPageIterator struct {
	client RolePermissionsMapClient
	ctx context.Context
	cursor string
	started bool
	page RolePermissionMapPage
	err error
}

// RolePermissions returns a typed client scoped to the RolePermission table.
func (c DB) RolePermissions() RolePermissionsClient { return RolePermissionsClient{core: c.core, q: c.core.From(Tables.RolePermission)} }

func (c RolePermissionsClient) Where(cond onyx.Condition) RolePermissionsClient { c.q = c.q.Where(cond); return c }
func (c RolePermissionsClient) And(cond onyx.Condition) RolePermissionsClient { c.q = c.q.And(cond); return c }
func (c RolePermissionsClient) Or(cond onyx.Condition) RolePermissionsClient { c.q = c.q.Or(cond); return c }
func (c RolePermissionsClient) Resolve(resolvers ...string) RolePermissionsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolePermissionsClient) OrderBy(field string, asc bool) RolePermissionsClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolePermissionsClient) Limit(n int) RolePermissionsClient { c.q = c.q.Limit(n); return c }
func (c RolePermissionsClient) SetUpdates(updates map[string]any) RolePermissionsClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolePermissionsClient) SetRolePermissionUpdates(updates *RolePermissionUpdates) RolePermissionsClient {
	if updates == nil {
		return c
	}
	c.q = c.q.SetUpdates(updates.valuesMap())
	return c
}
func (c RolePermissionsClient) Select(fields ...string) RolePermissionsMapClient {
	c.q = c.q.Select(fields...)
	return RolePermissionsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c RolePermissionsClient) GroupBy(fields ...string) RolePermissionsMapClient {
	c.q = c.q.GroupBy(fields...)
	return RolePermissionsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c RolePermissionsClient) AsMaps() RolePermissionsMapClient { return RolePermissionsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c RolePermissionsClient) WithTimeout(d time.Duration) RolePermissionsClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c RolePermissionsClient) WithDefaultTimeout() RolePermissionsClient { return c.WithTimeout(30 * time.Second) }
func (c RolePermissionsClient) WithShortTimeout() RolePermissionsClient { return c.WithTimeout(5 * time.Second) }
func (c RolePermissionsClient) WithLongTimeout() RolePermissionsClient { return c.WithTimeout(2 * time.Minute) }
func (c RolePermissionsClient) WithHook(h QueryHook) RolePermissionsClient { c.hook = h; return c }
func (c RolePermissionsClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.RolePermission)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c RolePermissionsClient) List(ctx context.Context) ([]RolePermission, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list", Tables.RolePermission)
	res := onyx.List(ctx, c.q)
	var out []RolePermission
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode RolePermission list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c RolePermissionsClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.RolePermission)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode RolePermission map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c RolePermissionsClient) Page(ctx context.Context, cursor string) (RolePermissionPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.RolePermission)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page rolepermission: %w", err)
		done(err)
		return RolePermissionPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return RolePermissionPage{Items: []RolePermission{}, NextCursor: res.NextCursor}, nil
	}
	var items []RolePermission
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode rolepermission page: %w", err)
		done(err)
		return RolePermissionPage{}, err
	}
	done(nil)
	return RolePermissionPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c RolePermissionsClient) Pages(ctx context.Context) *RolePermissionsPageIterator { return &RolePermissionsPageIterator{client: c, ctx: ctx} }

func (c RolePermissionsClient) PageOfMaps(ctx context.Context, cursor string) (RolePermissionMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.RolePermission)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page rolepermission maps: %w", err)
		done(err)
		return RolePermissionMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return RolePermissionMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return RolePermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolePermissionsClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.RolePermission)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update RolePermission: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c RolePermissionsClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.RolePermission)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete RolePermission: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c RolePermissionsClient) Save(ctx context.Context, item RolePermission, cascades ...onyx.CascadeSpec) (RolePermission, error) {
	if err := validateRolePermission(item); err != nil {
		return RolePermission{}, err
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return RolePermission{}, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "save", Tables.RolePermission)
	saved, err := c.core.Save(ctx, Tables.RolePermission, item, relationships)
	if err != nil {
		err = fmt.Errorf("failed to save rolepermission: %w", err)
		done(err)
		return RolePermission{}, err
	}
	var out RolePermission
	if err := decodeSaved(saved, &out); err != nil {
		err = fmt.Errorf("failed to decode saved rolepermission: %w", err)
		done(err)
		return RolePermission{}, err
	}
	done(nil)
	return out, nil
}

func (c RolePermissionsClient) SaveMany(ctx context.Context, items []RolePermission, cascades ...onyx.CascadeSpec) ([]RolePermission, error) {
	if len(items) == 0 {
		return nil, nil
	}
	for i, item := range items {
		if err := validateRolePermission(item); err != nil {
			return nil, fmt.Errorf("rolepermission at index %d: %w", i, err)
		}
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return nil, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	out := make([]RolePermission, 0, len(items))
	for i, item := range items {
		ctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, "save_many", Tables.RolePermission)
		saved, err := c.core.Save(ctxOp, Tables.RolePermission, item, relationships)
		if err != nil {
			err = fmt.Errorf("failed to save rolepermission at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		var decoded RolePermission
		if err := decodeSaved(saved, &decoded); err != nil {
			err = fmt.Errorf("failed to decode saved rolepermission at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		done(nil)
		out = append(out, decoded)
	}
	return out, nil
}

func (c RolePermissionsClient) DeleteByID(ctx context.Context, id string) (int, error) {
	if id == "" {
		return 0, fmt.Errorf("rolepermission id cannot be empty")
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete_by_id", Tables.RolePermission)
	err := c.core.Delete(ctx, Tables.RolePermission, id)
	if err != nil {
		err = fmt.Errorf("failed to delete rolepermission %s: %w", id, err)
		done(err)
		return 0, err
	}
	done(nil)
	return 1, nil
}

func (c RolePermissionsClient) DeleteByIDs(ctx context.Context, ids []string) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	for i, id := range ids {
		if id == "" {
			return 0, fmt.Errorf("id at index %d is empty", i)
		}
	}
	client := c.Where(onyx.In("id", toAnyStrings(ids)))
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "delete_many", Tables.RolePermission)
	n, err := client.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete rolepermission by ids: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c RolePermissionsClient) FindByID(ctx context.Context, id string) (RolePermission, error) {
	if id == "" {
		return RolePermission{}, fmt.Errorf("rolepermission id cannot be empty")
	}
	items, err := c.Where(onyx.Eq("id", id)).Limit(1).List(ctx)
	if err != nil {
		return RolePermission{}, fmt.Errorf("failed to find rolepermission by id %s: %w", id, err)
	}
	if len(items) == 0 {
		return RolePermission{}, nil
	}
	return items[0], nil
}

func (c RolePermissionsMapClient) Where(cond onyx.Condition) RolePermissionsMapClient { c.q = c.q.Where(cond); return c }
func (c RolePermissionsMapClient) And(cond onyx.Condition) RolePermissionsMapClient { c.q = c.q.And(cond); return c }
func (c RolePermissionsMapClient) Or(cond onyx.Condition) RolePermissionsMapClient { c.q = c.q.Or(cond); return c }
func (c RolePermissionsMapClient) Resolve(resolvers ...string) RolePermissionsMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolePermissionsMapClient) OrderBy(field string, asc bool) RolePermissionsMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolePermissionsMapClient) Limit(n int) RolePermissionsMapClient { c.q = c.q.Limit(n); return c }
func (c RolePermissionsMapClient) SetUpdates(updates map[string]any) RolePermissionsMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolePermissionsMapClient) Select(fields ...string) RolePermissionsMapClient { c.q = c.q.Select(fields...); return c }
func (c RolePermissionsMapClient) GroupBy(fields ...string) RolePermissionsMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c RolePermissionsMapClient) WithTimeout(d time.Duration) RolePermissionsMapClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c RolePermissionsMapClient) WithDefaultTimeout() RolePermissionsMapClient { return c.WithTimeout(30 * time.Second) }
func (c RolePermissionsMapClient) WithShortTimeout() RolePermissionsMapClient { return c.WithTimeout(5 * time.Second) }
func (c RolePermissionsMapClient) WithLongTimeout() RolePermissionsMapClient { return c.WithTimeout(2 * time.Minute) }
func (c RolePermissionsMapClient) WithHook(h QueryHook) RolePermissionsMapClient { c.hook = h; return c }
func (c RolePermissionsMapClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.RolePermission)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c RolePermissionsMapClient) List(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.RolePermission)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode rolepermission map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c RolePermissionsMapClient) Page(ctx context.Context, cursor string) (RolePermissionMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.RolePermission)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page rolepermission maps: %w", err)
		done(err)
		return RolePermissionMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return RolePermissionMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return RolePermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolePermissionsMapClient) Pages(ctx context.Context) *RolePermissionsMapPageIterator { return &RolePermissionsMapPageIterator{client: c, ctx: ctx} }

func (c RolePermissionsMapClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.RolePermission)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update rolepermission maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c RolePermissionsMapClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.RolePermission)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete rolepermission maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (it *RolePermissionsPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *RolePermissionsPageIterator) Page() (RolePermissionPage, error) {
	if it.err != nil {
		return RolePermissionPage{}, it.err
	}
	return it.page, nil
}

func (it *RolePermissionsPageIterator) Err() error { return it.err }

func (it *RolePermissionsPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.RolePermission)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page rolepermission: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = RolePermissionPage{Items: []RolePermission{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	var items []RolePermission
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode rolepermission page: %w", err)
		done(err)
		return err
	}
	it.page = RolePermissionPage{Items: items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

func (it *RolePermissionsMapPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *RolePermissionsMapPageIterator) Page() (RolePermissionMapPage, error) {
	if it.err != nil {
		return RolePermissionMapPage{}, it.err
	}
	return it.page, nil
}

func (it *RolePermissionsMapPageIterator) Err() error { return it.err }

func (it *RolePermissionsMapPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.RolePermission)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page rolepermission maps: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = RolePermissionMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	it.page = RolePermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

