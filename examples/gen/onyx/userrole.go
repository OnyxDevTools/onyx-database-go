// Code generated by onyx-gen-go; DO NOT EDIT.
// Generated at: 2026-01-10T03:17:54Z

package onyx

import (
	"context"
	"time"
	"fmt"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type UserRole struct {
	CreatedAt time.Time `json:"createdAt,omitempty"`
	Id string `json:"id,omitempty"`
	RoleId string `json:"roleId,omitempty"`
	UserId string `json:"userId,omitempty"`
	Role any `json:"role,omitempty"`
}

// UserRoleUpdates provides typed setters for update operations on UserRole.
type UserRoleUpdates struct { values map[string]any }

func NewUserRoleUpdates() *UserRoleUpdates { return &UserRoleUpdates{values: make(map[string]any)} }

func (u *UserRoleUpdates) SetCreatedAt(v time.Time) *UserRoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["createdAt"] = v
	return u
}

func (u *UserRoleUpdates) SetId(v string) *UserRoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["id"] = v
	return u
}

func (u *UserRoleUpdates) SetRoleId(v string) *UserRoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["roleId"] = v
	return u
}

func (u *UserRoleUpdates) SetUserId(v string) *UserRoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["userId"] = v
	return u
}

func (u *UserRoleUpdates) valuesMap() map[string]any { return u.values }

type UserRolePage struct {
	Items []UserRole `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserRoleMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

func validateUserRole(item UserRole) error {
	if item.RoleId == "" {
		return fmt.Errorf("userrole roleId is required")
	}
	if item.UserId == "" {
		return fmt.Errorf("userrole userId is required")
	}
	return nil
}

// UserRolesClient provides a fluent API for querying and manipulating UserRole records.
// All methods return a new client instance, allowing for method chaining.
//
// Example:
//   items, err := db.UserRoles().
//       Where(onyx.Eq("isActive", true)).
//       OrderBy("createdAt", false).
//       Limit(10).
//       List(ctx)
type UserRolesClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }
// UserRolesMapClient provides map-based query helpers returned from Select/GroupBy operations.
type UserRolesMapClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }

// UserRoleRepository captures the full set of UserRolesClient operations for easy mocking in tests.
type UserRoleRepository interface {
	Where(cond onyx.Condition) UserRolesClient
	And(cond onyx.Condition) UserRolesClient
	Or(cond onyx.Condition) UserRolesClient
	Resolve(resolvers ...string) UserRolesClient
	OrderBy(field string, asc bool) UserRolesClient
	Limit(n int) UserRolesClient
	SetUpdates(updates map[string]any) UserRolesClient
	SetUserRoleUpdates(updates *UserRoleUpdates) UserRolesClient
	Select(fields ...string) UserRolesMapClient
	GroupBy(fields ...string) UserRolesMapClient
	AsMaps() UserRolesMapClient
	WithTimeout(d time.Duration) UserRolesClient
	WithDefaultTimeout() UserRolesClient
	WithShortTimeout() UserRolesClient
	WithLongTimeout() UserRolesClient
	WithHook(h QueryHook) UserRolesClient
	Stream(ctx context.Context) (onyx.Iterator, error)
	List(ctx context.Context) ([]UserRole, error)
	ListMaps(ctx context.Context) ([]map[string]any, error)
	Page(ctx context.Context, cursor string) (UserRolePage, error)
	Pages(ctx context.Context) *UserRolesPageIterator
	PageOfMaps(ctx context.Context, cursor string) (UserRoleMapPage, error)
	Update(ctx context.Context) (int, error)
	Delete(ctx context.Context) (int, error)
	Save(ctx context.Context, item UserRole, cascades ...onyx.CascadeSpec) (UserRole, error)
	SaveMany(ctx context.Context, items []UserRole, cascades ...onyx.CascadeSpec) ([]UserRole, error)
	DeleteByID(ctx context.Context, id string) (int, error)
	DeleteByIDs(ctx context.Context, ids []string) (int, error)
	FindByID(ctx context.Context, id string) (UserRole, error)
}

// UserRolesPageIterator iterates over paginated UserRole results.
type UserRolesPageIterator struct {
	client UserRolesClient
	ctx context.Context
	cursor string
	started bool
	page UserRolePage
	err error
}

// UserRolesMapPageIterator iterates over paginated map results for UserRole queries.
type UserRolesMapPageIterator struct {
	client UserRolesMapClient
	ctx context.Context
	cursor string
	started bool
	page UserRoleMapPage
	err error
}

// UserRoles returns a typed client scoped to the UserRole table.
func (c DB) UserRoles() UserRolesClient { return UserRolesClient{core: c.core, q: c.core.From(Tables.UserRole)} }

func (c UserRolesClient) Where(cond onyx.Condition) UserRolesClient { c.q = c.q.Where(cond); return c }
func (c UserRolesClient) And(cond onyx.Condition) UserRolesClient { c.q = c.q.And(cond); return c }
func (c UserRolesClient) Or(cond onyx.Condition) UserRolesClient { c.q = c.q.Or(cond); return c }
func (c UserRolesClient) Resolve(resolvers ...string) UserRolesClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserRolesClient) OrderBy(field string, asc bool) UserRolesClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserRolesClient) Limit(n int) UserRolesClient { c.q = c.q.Limit(n); return c }
func (c UserRolesClient) SetUpdates(updates map[string]any) UserRolesClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserRolesClient) SetUserRoleUpdates(updates *UserRoleUpdates) UserRolesClient {
	if updates == nil {
		return c
	}
	c.q = c.q.SetUpdates(updates.valuesMap())
	return c
}
func (c UserRolesClient) Select(fields ...string) UserRolesMapClient {
	c.q = c.q.Select(fields...)
	return UserRolesMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c UserRolesClient) GroupBy(fields ...string) UserRolesMapClient {
	c.q = c.q.GroupBy(fields...)
	return UserRolesMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c UserRolesClient) AsMaps() UserRolesMapClient { return UserRolesMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c UserRolesClient) WithTimeout(d time.Duration) UserRolesClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c UserRolesClient) WithDefaultTimeout() UserRolesClient { return c.WithTimeout(30 * time.Second) }
func (c UserRolesClient) WithShortTimeout() UserRolesClient { return c.WithTimeout(5 * time.Second) }
func (c UserRolesClient) WithLongTimeout() UserRolesClient { return c.WithTimeout(2 * time.Minute) }
func (c UserRolesClient) WithHook(h QueryHook) UserRolesClient { c.hook = h; return c }
func (c UserRolesClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.UserRole)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c UserRolesClient) List(ctx context.Context) ([]UserRole, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list", Tables.UserRole)
	res := onyx.List(ctx, c.q)
	var out []UserRole
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode UserRole list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c UserRolesClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.UserRole)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode UserRole map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c UserRolesClient) Page(ctx context.Context, cursor string) (UserRolePage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.UserRole)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userrole: %w", err)
		done(err)
		return UserRolePage{}, err
	}
	if res.Items == nil {
		done(nil)
		return UserRolePage{Items: []UserRole{}, NextCursor: res.NextCursor}, nil
	}
	var items []UserRole
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode userrole page: %w", err)
		done(err)
		return UserRolePage{}, err
	}
	done(nil)
	return UserRolePage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c UserRolesClient) Pages(ctx context.Context) *UserRolesPageIterator { return &UserRolesPageIterator{client: c, ctx: ctx} }

func (c UserRolesClient) PageOfMaps(ctx context.Context, cursor string) (UserRoleMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.UserRole)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userrole maps: %w", err)
		done(err)
		return UserRoleMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return UserRoleMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return UserRoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserRolesClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.UserRole)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update UserRole: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UserRolesClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.UserRole)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete UserRole: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UserRolesClient) Save(ctx context.Context, item UserRole, cascades ...onyx.CascadeSpec) (UserRole, error) {
	if err := validateUserRole(item); err != nil {
		return UserRole{}, err
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return UserRole{}, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "save", Tables.UserRole)
	saved, err := c.core.Save(ctx, Tables.UserRole, item, relationships)
	if err != nil {
		err = fmt.Errorf("failed to save userrole: %w", err)
		done(err)
		return UserRole{}, err
	}
	var out UserRole
	if err := decodeSaved(saved, &out); err != nil {
		err = fmt.Errorf("failed to decode saved userrole: %w", err)
		done(err)
		return UserRole{}, err
	}
	done(nil)
	return out, nil
}

func (c UserRolesClient) SaveMany(ctx context.Context, items []UserRole, cascades ...onyx.CascadeSpec) ([]UserRole, error) {
	if len(items) == 0 {
		return nil, nil
	}
	for i, item := range items {
		if err := validateUserRole(item); err != nil {
			return nil, fmt.Errorf("userrole at index %d: %w", i, err)
		}
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return nil, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	out := make([]UserRole, 0, len(items))
	for i, item := range items {
		ctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, "save_many", Tables.UserRole)
		saved, err := c.core.Save(ctxOp, Tables.UserRole, item, relationships)
		if err != nil {
			err = fmt.Errorf("failed to save userrole at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		var decoded UserRole
		if err := decodeSaved(saved, &decoded); err != nil {
			err = fmt.Errorf("failed to decode saved userrole at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		done(nil)
		out = append(out, decoded)
	}
	return out, nil
}

func (c UserRolesClient) DeleteByID(ctx context.Context, id string) (int, error) {
	if id == "" {
		return 0, fmt.Errorf("userrole id cannot be empty")
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete_by_id", Tables.UserRole)
	err := c.core.Delete(ctx, Tables.UserRole, id)
	if err != nil {
		err = fmt.Errorf("failed to delete userrole %s: %w", id, err)
		done(err)
		return 0, err
	}
	done(nil)
	return 1, nil
}

func (c UserRolesClient) DeleteByIDs(ctx context.Context, ids []string) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	for i, id := range ids {
		if id == "" {
			return 0, fmt.Errorf("id at index %d is empty", i)
		}
	}
	client := c.Where(onyx.In("id", toAnyStrings(ids)))
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "delete_many", Tables.UserRole)
	n, err := client.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete userrole by ids: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UserRolesClient) FindByID(ctx context.Context, id string) (UserRole, error) {
	if id == "" {
		return UserRole{}, fmt.Errorf("userrole id cannot be empty")
	}
	items, err := c.Where(onyx.Eq("id", id)).Limit(1).List(ctx)
	if err != nil {
		return UserRole{}, fmt.Errorf("failed to find userrole by id %s: %w", id, err)
	}
	if len(items) == 0 {
		return UserRole{}, nil
	}
	return items[0], nil
}

func (c UserRolesMapClient) Where(cond onyx.Condition) UserRolesMapClient { c.q = c.q.Where(cond); return c }
func (c UserRolesMapClient) And(cond onyx.Condition) UserRolesMapClient { c.q = c.q.And(cond); return c }
func (c UserRolesMapClient) Or(cond onyx.Condition) UserRolesMapClient { c.q = c.q.Or(cond); return c }
func (c UserRolesMapClient) Resolve(resolvers ...string) UserRolesMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserRolesMapClient) OrderBy(field string, asc bool) UserRolesMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserRolesMapClient) Limit(n int) UserRolesMapClient { c.q = c.q.Limit(n); return c }
func (c UserRolesMapClient) SetUpdates(updates map[string]any) UserRolesMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserRolesMapClient) Select(fields ...string) UserRolesMapClient { c.q = c.q.Select(fields...); return c }
func (c UserRolesMapClient) GroupBy(fields ...string) UserRolesMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c UserRolesMapClient) WithTimeout(d time.Duration) UserRolesMapClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c UserRolesMapClient) WithDefaultTimeout() UserRolesMapClient { return c.WithTimeout(30 * time.Second) }
func (c UserRolesMapClient) WithShortTimeout() UserRolesMapClient { return c.WithTimeout(5 * time.Second) }
func (c UserRolesMapClient) WithLongTimeout() UserRolesMapClient { return c.WithTimeout(2 * time.Minute) }
func (c UserRolesMapClient) WithHook(h QueryHook) UserRolesMapClient { c.hook = h; return c }
func (c UserRolesMapClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.UserRole)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c UserRolesMapClient) List(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.UserRole)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode userrole map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c UserRolesMapClient) Page(ctx context.Context, cursor string) (UserRoleMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.UserRole)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userrole maps: %w", err)
		done(err)
		return UserRoleMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return UserRoleMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return UserRoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserRolesMapClient) Pages(ctx context.Context) *UserRolesMapPageIterator { return &UserRolesMapPageIterator{client: c, ctx: ctx} }

func (c UserRolesMapClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.UserRole)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update userrole maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UserRolesMapClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.UserRole)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete userrole maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (it *UserRolesPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *UserRolesPageIterator) Page() (UserRolePage, error) {
	if it.err != nil {
		return UserRolePage{}, it.err
	}
	return it.page, nil
}

func (it *UserRolesPageIterator) Err() error { return it.err }

func (it *UserRolesPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.UserRole)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userrole: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = UserRolePage{Items: []UserRole{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	var items []UserRole
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode userrole page: %w", err)
		done(err)
		return err
	}
	it.page = UserRolePage{Items: items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

func (it *UserRolesMapPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *UserRolesMapPageIterator) Page() (UserRoleMapPage, error) {
	if it.err != nil {
		return UserRoleMapPage{}, it.err
	}
	return it.page, nil
}

func (it *UserRolesMapPageIterator) Err() error { return it.err }

func (it *UserRolesMapPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.UserRole)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userrole maps: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = UserRoleMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	it.page = UserRoleMapPage{Items: res.Items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

