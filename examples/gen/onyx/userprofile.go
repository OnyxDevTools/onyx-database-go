// Code generated by onyx-gen-go; DO NOT EDIT.
// Generated at: 2026-01-19T03:20:40Z

package onyx

import (
	"context"
	"time"
	"fmt"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type UserProfile struct {
	Address map[string]any `json:"address,omitempty"`
	Age *int64 `json:"age,omitempty"`
	AvatarUrl *string `json:"avatarUrl,omitempty"`
	Bio *string `json:"bio,omitempty"`
	CreatedAt time.Time `json:"createdAt,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	FirstName string `json:"firstName,omitempty"`
	Id string `json:"id,omitempty"`
	LastName string `json:"lastName,omitempty"`
	Phone *string `json:"phone,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	UserId string `json:"userId,omitempty"`
}

// UserProfileUpdates provides typed setters for update operations on UserProfile.
type UserProfileUpdates struct { values map[string]any }

func NewUserProfileUpdates() *UserProfileUpdates { return &UserProfileUpdates{values: make(map[string]any)} }

func (u *UserProfileUpdates) SetAddress(v map[string]any) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["address"] = v
	return u
}

func (u *UserProfileUpdates) SetAge(v *int64) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["age"] = v
	return u
}

func (u *UserProfileUpdates) SetAvatarUrl(v *string) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["avatarUrl"] = v
	return u
}

func (u *UserProfileUpdates) SetBio(v *string) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["bio"] = v
	return u
}

func (u *UserProfileUpdates) SetCreatedAt(v time.Time) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["createdAt"] = v
	return u
}

func (u *UserProfileUpdates) SetDeletedAt(v *time.Time) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["deletedAt"] = v
	return u
}

func (u *UserProfileUpdates) SetFirstName(v string) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["firstName"] = v
	return u
}

func (u *UserProfileUpdates) SetId(v string) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["id"] = v
	return u
}

func (u *UserProfileUpdates) SetLastName(v string) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["lastName"] = v
	return u
}

func (u *UserProfileUpdates) SetPhone(v *string) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["phone"] = v
	return u
}

func (u *UserProfileUpdates) SetUpdatedAt(v *time.Time) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["updatedAt"] = v
	return u
}

func (u *UserProfileUpdates) SetUserId(v string) *UserProfileUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["userId"] = v
	return u
}

func (u *UserProfileUpdates) valuesMap() map[string]any { return u.values }

type UserProfilePage struct {
	Items []UserProfile `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserProfileMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

func validateUserProfile(item UserProfile) error {
	if item.FirstName == "" {
		return fmt.Errorf("userprofile firstName is required")
	}
	if item.LastName == "" {
		return fmt.Errorf("userprofile lastName is required")
	}
	if item.UserId == "" {
		return fmt.Errorf("userprofile userId is required")
	}
	return nil
}

// UserProfilesClient provides a fluent API for querying and manipulating UserProfile records.
// All methods return a new client instance, allowing for method chaining.
//
// Example:
//   items, err := db.UserProfiles().
//       Where(onyx.Eq("isActive", true)).
//       OrderBy("createdAt", false).
//       Limit(10).
//       List(ctx)
type UserProfilesClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }
// UserProfilesMapClient provides map-based query helpers returned from Select/GroupBy operations.
type UserProfilesMapClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }

// UserProfileRepository captures the full set of UserProfilesClient operations for easy mocking in tests.
type UserProfileRepository interface {
	Where(cond onyx.Condition) UserProfilesClient
	And(cond onyx.Condition) UserProfilesClient
	Or(cond onyx.Condition) UserProfilesClient
	Resolve(resolvers ...string) UserProfilesClient
	OrderBy(field string, asc bool) UserProfilesClient
	Limit(n int) UserProfilesClient
	SetUpdates(updates map[string]any) UserProfilesClient
	SetUserProfileUpdates(updates *UserProfileUpdates) UserProfilesClient
	Select(fields ...string) UserProfilesMapClient
	GroupBy(fields ...string) UserProfilesMapClient
	AsMaps() UserProfilesMapClient
	WithTimeout(d time.Duration) UserProfilesClient
	WithDefaultTimeout() UserProfilesClient
	WithShortTimeout() UserProfilesClient
	WithLongTimeout() UserProfilesClient
	WithHook(h QueryHook) UserProfilesClient
	Stream(ctx context.Context) (onyx.Iterator, error)
	List(ctx context.Context) ([]UserProfile, error)
	ListMaps(ctx context.Context) ([]map[string]any, error)
	Page(ctx context.Context, cursor string) (UserProfilePage, error)
	Pages(ctx context.Context) *UserProfilesPageIterator
	PageOfMaps(ctx context.Context, cursor string) (UserProfileMapPage, error)
	Update(ctx context.Context) (int, error)
	Delete(ctx context.Context) (int, error)
	Save(ctx context.Context, item UserProfile, cascades ...onyx.CascadeSpec) (UserProfile, error)
	SaveMany(ctx context.Context, items []UserProfile, cascades ...onyx.CascadeSpec) ([]UserProfile, error)
	DeleteByID(ctx context.Context, id string) (int, error)
	DeleteByIDs(ctx context.Context, ids []string) (int, error)
	FindByID(ctx context.Context, id string) (UserProfile, error)
}

// UserProfilesPageIterator iterates over paginated UserProfile results.
type UserProfilesPageIterator struct {
	client UserProfilesClient
	ctx context.Context
	cursor string
	started bool
	page UserProfilePage
	err error
}

// UserProfilesMapPageIterator iterates over paginated map results for UserProfile queries.
type UserProfilesMapPageIterator struct {
	client UserProfilesMapClient
	ctx context.Context
	cursor string
	started bool
	page UserProfileMapPage
	err error
}

// UserProfiles returns a typed client scoped to the UserProfile table.
func (c DB) UserProfiles() UserProfilesClient { return UserProfilesClient{core: c.core, q: c.core.From(Tables.UserProfile)} }

func (c UserProfilesClient) Where(cond onyx.Condition) UserProfilesClient { c.q = c.q.Where(cond); return c }
func (c UserProfilesClient) And(cond onyx.Condition) UserProfilesClient { c.q = c.q.And(cond); return c }
func (c UserProfilesClient) Or(cond onyx.Condition) UserProfilesClient { c.q = c.q.Or(cond); return c }
func (c UserProfilesClient) Resolve(resolvers ...string) UserProfilesClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserProfilesClient) OrderBy(field string, asc bool) UserProfilesClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserProfilesClient) Limit(n int) UserProfilesClient { c.q = c.q.Limit(n); return c }
func (c UserProfilesClient) SetUpdates(updates map[string]any) UserProfilesClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserProfilesClient) SetUserProfileUpdates(updates *UserProfileUpdates) UserProfilesClient {
	if updates == nil {
		return c
	}
	c.q = c.q.SetUpdates(updates.valuesMap())
	return c
}
func (c UserProfilesClient) Select(fields ...string) UserProfilesMapClient {
	c.q = c.q.Select(fields...)
	return UserProfilesMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c UserProfilesClient) GroupBy(fields ...string) UserProfilesMapClient {
	c.q = c.q.GroupBy(fields...)
	return UserProfilesMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c UserProfilesClient) AsMaps() UserProfilesMapClient { return UserProfilesMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c UserProfilesClient) WithTimeout(d time.Duration) UserProfilesClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c UserProfilesClient) WithDefaultTimeout() UserProfilesClient { return c.WithTimeout(30 * time.Second) }
func (c UserProfilesClient) WithShortTimeout() UserProfilesClient { return c.WithTimeout(5 * time.Second) }
func (c UserProfilesClient) WithLongTimeout() UserProfilesClient { return c.WithTimeout(2 * time.Minute) }
func (c UserProfilesClient) WithHook(h QueryHook) UserProfilesClient { c.hook = h; return c }
func (c UserProfilesClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.UserProfile)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c UserProfilesClient) List(ctx context.Context) ([]UserProfile, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list", Tables.UserProfile)
	res := onyx.List(ctx, c.q)
	var out []UserProfile
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode UserProfile list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c UserProfilesClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.UserProfile)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode UserProfile map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c UserProfilesClient) Page(ctx context.Context, cursor string) (UserProfilePage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.UserProfile)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userprofile: %w", err)
		done(err)
		return UserProfilePage{}, err
	}
	if res.Items == nil {
		done(nil)
		return UserProfilePage{Items: []UserProfile{}, NextCursor: res.NextCursor}, nil
	}
	var items []UserProfile
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode userprofile page: %w", err)
		done(err)
		return UserProfilePage{}, err
	}
	done(nil)
	return UserProfilePage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c UserProfilesClient) Pages(ctx context.Context) *UserProfilesPageIterator { return &UserProfilesPageIterator{client: c, ctx: ctx} }

func (c UserProfilesClient) PageOfMaps(ctx context.Context, cursor string) (UserProfileMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.UserProfile)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userprofile maps: %w", err)
		done(err)
		return UserProfileMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return UserProfileMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return UserProfileMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserProfilesClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.UserProfile)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update UserProfile: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UserProfilesClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.UserProfile)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete UserProfile: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UserProfilesClient) Save(ctx context.Context, item UserProfile, cascades ...onyx.CascadeSpec) (UserProfile, error) {
	if err := validateUserProfile(item); err != nil {
		return UserProfile{}, err
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return UserProfile{}, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "save", Tables.UserProfile)
	saved, err := c.core.Save(ctx, Tables.UserProfile, item, relationships)
	if err != nil {
		err = fmt.Errorf("failed to save userprofile: %w", err)
		done(err)
		return UserProfile{}, err
	}
	var out UserProfile
	if err := decodeSaved(saved, &out); err != nil {
		err = fmt.Errorf("failed to decode saved userprofile: %w", err)
		done(err)
		return UserProfile{}, err
	}
	done(nil)
	return out, nil
}

func (c UserProfilesClient) SaveMany(ctx context.Context, items []UserProfile, cascades ...onyx.CascadeSpec) ([]UserProfile, error) {
	if len(items) == 0 {
		return nil, nil
	}
	for i, item := range items {
		if err := validateUserProfile(item); err != nil {
			return nil, fmt.Errorf("userprofile at index %d: %w", i, err)
		}
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return nil, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	out := make([]UserProfile, 0, len(items))
	for i, item := range items {
		ctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, "save_many", Tables.UserProfile)
		saved, err := c.core.Save(ctxOp, Tables.UserProfile, item, relationships)
		if err != nil {
			err = fmt.Errorf("failed to save userprofile at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		var decoded UserProfile
		if err := decodeSaved(saved, &decoded); err != nil {
			err = fmt.Errorf("failed to decode saved userprofile at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		done(nil)
		out = append(out, decoded)
	}
	return out, nil
}

func (c UserProfilesClient) DeleteByID(ctx context.Context, id string) (int, error) {
	if id == "" {
		return 0, fmt.Errorf("userprofile id cannot be empty")
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete_by_id", Tables.UserProfile)
	err := c.core.Delete(ctx, Tables.UserProfile, id)
	if err != nil {
		err = fmt.Errorf("failed to delete userprofile %s: %w", id, err)
		done(err)
		return 0, err
	}
	done(nil)
	return 1, nil
}

func (c UserProfilesClient) DeleteByIDs(ctx context.Context, ids []string) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	for i, id := range ids {
		if id == "" {
			return 0, fmt.Errorf("id at index %d is empty", i)
		}
	}
	client := c.Where(onyx.In("id", toAnyStrings(ids)))
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "delete_many", Tables.UserProfile)
	n, err := client.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete userprofile by ids: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UserProfilesClient) FindByID(ctx context.Context, id string) (UserProfile, error) {
	if id == "" {
		return UserProfile{}, fmt.Errorf("userprofile id cannot be empty")
	}
	items, err := c.Where(onyx.Eq("id", id)).Limit(1).List(ctx)
	if err != nil {
		return UserProfile{}, fmt.Errorf("failed to find userprofile by id %s: %w", id, err)
	}
	if len(items) == 0 {
		return UserProfile{}, nil
	}
	return items[0], nil
}

func (c UserProfilesMapClient) Where(cond onyx.Condition) UserProfilesMapClient { c.q = c.q.Where(cond); return c }
func (c UserProfilesMapClient) And(cond onyx.Condition) UserProfilesMapClient { c.q = c.q.And(cond); return c }
func (c UserProfilesMapClient) Or(cond onyx.Condition) UserProfilesMapClient { c.q = c.q.Or(cond); return c }
func (c UserProfilesMapClient) Resolve(resolvers ...string) UserProfilesMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserProfilesMapClient) OrderBy(field string, asc bool) UserProfilesMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserProfilesMapClient) Limit(n int) UserProfilesMapClient { c.q = c.q.Limit(n); return c }
func (c UserProfilesMapClient) SetUpdates(updates map[string]any) UserProfilesMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserProfilesMapClient) Select(fields ...string) UserProfilesMapClient { c.q = c.q.Select(fields...); return c }
func (c UserProfilesMapClient) GroupBy(fields ...string) UserProfilesMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c UserProfilesMapClient) WithTimeout(d time.Duration) UserProfilesMapClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c UserProfilesMapClient) WithDefaultTimeout() UserProfilesMapClient { return c.WithTimeout(30 * time.Second) }
func (c UserProfilesMapClient) WithShortTimeout() UserProfilesMapClient { return c.WithTimeout(5 * time.Second) }
func (c UserProfilesMapClient) WithLongTimeout() UserProfilesMapClient { return c.WithTimeout(2 * time.Minute) }
func (c UserProfilesMapClient) WithHook(h QueryHook) UserProfilesMapClient { c.hook = h; return c }
func (c UserProfilesMapClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.UserProfile)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c UserProfilesMapClient) List(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.UserProfile)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode userprofile map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c UserProfilesMapClient) Page(ctx context.Context, cursor string) (UserProfileMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.UserProfile)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userprofile maps: %w", err)
		done(err)
		return UserProfileMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return UserProfileMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return UserProfileMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserProfilesMapClient) Pages(ctx context.Context) *UserProfilesMapPageIterator { return &UserProfilesMapPageIterator{client: c, ctx: ctx} }

func (c UserProfilesMapClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.UserProfile)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update userprofile maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c UserProfilesMapClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.UserProfile)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete userprofile maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (it *UserProfilesPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *UserProfilesPageIterator) Page() (UserProfilePage, error) {
	if it.err != nil {
		return UserProfilePage{}, it.err
	}
	return it.page, nil
}

func (it *UserProfilesPageIterator) Err() error { return it.err }

func (it *UserProfilesPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.UserProfile)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userprofile: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = UserProfilePage{Items: []UserProfile{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	var items []UserProfile
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode userprofile page: %w", err)
		done(err)
		return err
	}
	it.page = UserProfilePage{Items: items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

func (it *UserProfilesMapPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *UserProfilesMapPageIterator) Page() (UserProfileMapPage, error) {
	if it.err != nil {
		return UserProfileMapPage{}, it.err
	}
	return it.page, nil
}

func (it *UserProfilesMapPageIterator) Err() error { return it.err }

func (it *UserProfilesMapPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.UserProfile)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page userprofile maps: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = UserProfileMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	it.page = UserProfileMapPage{Items: res.Items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

