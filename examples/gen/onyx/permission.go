// Code generated by onyx gen --go; DO NOT EDIT.
// Generated at: 2026-02-01T04:27:49Z

package onyx

import (
	"context"
	"fmt"
	"time"

	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type Permission struct {
	CreatedAt time.Time `json:"createdAt,omitempty"`
	DeletedAt time.Time `json:"deletedAt,omitempty"`
	Description *string `json:"description,omitempty"`
	Id string `json:"id,omitempty"`
	Name string `json:"name,omitempty"`
	UpdatedAt time.Time `json:"updatedAt,omitempty"`
}

// PermissionUpdates provides typed setters for update operations on Permission.
type PermissionUpdates struct { values map[string]any }

func NewPermissionUpdates() *PermissionUpdates { return &PermissionUpdates{values: make(map[string]any)} }

func (u *PermissionUpdates) SetCreatedAt(v time.Time) *PermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["createdAt"] = v
	return u
}

func (u *PermissionUpdates) SetDeletedAt(v time.Time) *PermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["deletedAt"] = v
	return u
}

func (u *PermissionUpdates) SetDescription(v *string) *PermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["description"] = v
	return u
}

func (u *PermissionUpdates) SetId(v string) *PermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["id"] = v
	return u
}

func (u *PermissionUpdates) SetName(v string) *PermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["name"] = v
	return u
}

func (u *PermissionUpdates) SetUpdatedAt(v time.Time) *PermissionUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["updatedAt"] = v
	return u
}

func (u *PermissionUpdates) valuesMap() map[string]any { return u.values }

type PermissionPage struct {
	Items []Permission `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type PermissionMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

// PermissionRepository captures the full set of PermissionsClient operations for easy mocking in tests.
type PermissionRepository interface {
	Where(cond onyx.Condition) PermissionsClient
	And(cond onyx.Condition) PermissionsClient
	Or(cond onyx.Condition) PermissionsClient
	Resolve(resolvers ...string) PermissionsClient
	OrderBy(field string, asc bool) PermissionsClient
	Limit(n int) PermissionsClient
	SetUpdates(updates map[string]any) PermissionsClient
	SetPermissionUpdates(updates *PermissionUpdates) PermissionsClient
	Select(fields ...string) PermissionsMapClient
	GroupBy(fields ...string) PermissionsMapClient
	AsMaps() PermissionsMapClient
	WithTimeout(d time.Duration) PermissionsClient
	WithDefaultTimeout() PermissionsClient
	WithShortTimeout() PermissionsClient
	WithLongTimeout() PermissionsClient
	WithHook(h QueryHook) PermissionsClient
	Stream(ctx context.Context) (onyx.Iterator, error)
	List(ctx context.Context) ([]Permission, error)
	ListMaps(ctx context.Context) ([]map[string]any, error)
	Page(ctx context.Context, cursor string) (PermissionPage, error)
	Pages(ctx context.Context) *PermissionsPageIterator
	PageOfMaps(ctx context.Context, cursor string) (PermissionMapPage, error)
	FirstOrNull(ctx context.Context) (*Permission, error)
	One(ctx context.Context) (Permission, error)
	Update(ctx context.Context) (int, error)
	Delete(ctx context.Context) (int, error)
	Save(ctx context.Context, item Permission, cascades ...onyx.CascadeSpec) (Permission, error)
	SaveMany(ctx context.Context, items []Permission, cascades ...onyx.CascadeSpec) ([]Permission, error)
	DeleteByID(ctx context.Context, id string) (int, error)
	DeleteByIDs(ctx context.Context, ids []string) (int, error)
	FindByID(ctx context.Context, id string) (Permission, error)
}

// PermissionsClient provides a fluent API for querying and manipulating Permission records.
type PermissionsClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }
// PermissionsMapClient provides map-based query helpers returned from Select/GroupBy operations.
type PermissionsMapClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }

// PermissionsPageIterator iterates over paginated Permission results.
type PermissionsPageIterator struct { client PermissionsClient; ctx context.Context; cursor string; started bool; page PermissionPage; err error }

// PermissionsMapPageIterator iterates over paginated map results for Permission queries.
type PermissionsMapPageIterator struct { client PermissionsMapClient; ctx context.Context; cursor string; started bool; page PermissionMapPage; err error }

// Permissions returns a typed client scoped to the Permission table.
func (c DB) Permissions() PermissionsClient { return PermissionsClient{core: c.core, q: c.core.From(Tables.Permission)} }

func (c PermissionsClient) Where(cond onyx.Condition) PermissionsClient { c.q = c.q.Where(cond); return c }
func (c PermissionsClient) And(cond onyx.Condition) PermissionsClient { c.q = c.q.And(cond); return c }
func (c PermissionsClient) Or(cond onyx.Condition) PermissionsClient { c.q = c.q.Or(cond); return c }
func (c PermissionsClient) Resolve(resolvers ...string) PermissionsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c PermissionsClient) OrderBy(field string, asc bool) PermissionsClient { if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }; return c }
func (c PermissionsClient) Limit(n int) PermissionsClient { c.q = c.q.Limit(n); return c }
func (c PermissionsClient) SetUpdates(updates map[string]any) PermissionsClient { c.q = c.q.SetUpdates(updates); return c }
func (c PermissionsClient) SetPermissionUpdates(updates *PermissionUpdates) PermissionsClient { if updates == nil { return c }; c.q = c.q.SetUpdates(updates.valuesMap()); return c }
func (c PermissionsClient) Select(fields ...string) PermissionsMapClient { c.q = c.q.Select(fields...); return PermissionsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c PermissionsClient) GroupBy(fields ...string) PermissionsMapClient { c.q = c.q.GroupBy(fields...); return PermissionsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c PermissionsClient) AsMaps() PermissionsMapClient { return PermissionsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c PermissionsClient) WithTimeout(d time.Duration) PermissionsClient { if d <= 0 { c.timeout = 30 * time.Second; return c }; c.timeout = d; return c }
func (c PermissionsClient) WithDefaultTimeout() PermissionsClient { return c.WithTimeout(30 * time.Second) }
func (c PermissionsClient) WithShortTimeout() PermissionsClient { return c.WithTimeout(5 * time.Second) }
func (c PermissionsClient) WithLongTimeout() PermissionsClient { return c.WithTimeout(2 * time.Minute) }
func (c PermissionsClient) WithHook(h QueryHook) PermissionsClient { c.hook = h; return c }
func (c PermissionsClient) Stream(ctx context.Context) (onyx.Iterator, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.Permission); iter, err := c.q.Stream(ctx); done(err); return iter, err }
func (c PermissionsClient) List(ctx context.Context) ([]Permission, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list", Tables.Permission); res := onyx.List(ctx, c.q); var out []Permission; if err := res.Decode(&out); err != nil { err = fmt.Errorf("failed to decode Permission list: %w", err); done(err); return nil, err }; done(nil); return out, nil }
func (c PermissionsClient) ListMaps(ctx context.Context) ([]map[string]any, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.Permission); res := onyx.List(ctx, c.q); var out []map[string]any; if err := res.Decode(&out); err != nil { err = fmt.Errorf("failed to decode Permission map list: %w", err); done(err); return nil, err }; done(nil); return out, nil }
func (c PermissionsClient) FirstOrNull(ctx context.Context) (*Permission, error) { limited := c.Limit(1); ctx, done := withContextAndHook(ctx, limited.timeout, limited.hook, "first_or_null", Tables.Permission); res := onyx.List(ctx, limited.q); var out []Permission; if err := res.Decode(&out); err != nil { err = fmt.Errorf("failed to decode permission first_or_null: %w", err); done(err); return nil, err }; done(nil); if len(out) == 0 { return nil, nil }; return &out[0], nil }
func (c PermissionsClient) One(ctx context.Context) (Permission, error) { limited := c.Limit(2); ctx, done := withContextAndHook(ctx, limited.timeout, limited.hook, "one", Tables.Permission); res := onyx.List(ctx, limited.q); var out []Permission; if err := res.Decode(&out); err != nil { err = fmt.Errorf("failed to decode permission one: %w", err); done(err); return Permission{}, err }; done(nil); if len(out) == 0 { return Permission{}, fmt.Errorf("expected one permission, got 0") }; if len(out) > 1 { return Permission{}, fmt.Errorf("expected one permission, got %d", len(out)) }; return out[0], nil }
func (c PermissionsClient) Page(ctx context.Context, cursor string) (PermissionPage, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.Permission); res, err := c.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf("failed to page permission: %w", err); done(err); return PermissionPage{}, err }; if res.Items == nil { done(nil); return PermissionPage{Items: []Permission{}, NextCursor: res.NextCursor}, nil }; var items []Permission; if err := decodeList(res.Items, &items); err != nil { err = fmt.Errorf("failed to decode permission page: %w", err); done(err); return PermissionPage{}, err }; done(nil); return PermissionPage{Items: items, NextCursor: res.NextCursor}, nil }
func (c PermissionsClient) Pages(ctx context.Context) *PermissionsPageIterator { return &PermissionsPageIterator{client: c, ctx: ctx} }
func (c PermissionsClient) PageOfMaps(ctx context.Context, cursor string) (PermissionMapPage, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.Permission); res, err := c.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf("failed to page permission maps: %w", err); done(err); return PermissionMapPage{}, err }; if res.Items == nil { done(nil); return PermissionMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil }; done(nil); return PermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil }
func (c PermissionsClient) Update(ctx context.Context) (int, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.Permission); n, err := c.q.Update(ctx); if err != nil { err = fmt.Errorf("failed to update permission: %w", err); done(err); return 0, err }; done(nil); return n, nil }
func (c PermissionsClient) Delete(ctx context.Context) (int, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.Permission); n, err := c.q.Delete(ctx); if err != nil { err = fmt.Errorf("failed to delete permission: %w", err); done(err); return 0, err }; done(nil); return n, nil }
func (c PermissionsClient) Save(ctx context.Context, item Permission, cascades ...onyx.CascadeSpec) (Permission, error) { var relationships []string; for i, spec := range cascades { if spec == nil { return Permission{}, fmt.Errorf("cascade spec at index %d is nil", i) }; relationships = append(relationships, spec.String()) }; ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "save", Tables.Permission); saved, err := c.core.Save(ctx, Tables.Permission, item, relationships); if err != nil { err = fmt.Errorf("failed to save permission: %w", err); done(err); return Permission{}, err }; var out Permission; if err := decodeSaved(saved, &out); err != nil { err = fmt.Errorf("failed to decode saved permission: %w", err); done(err); return Permission{}, err }; done(nil); return out, nil }
func (c PermissionsClient) SaveMany(ctx context.Context, items []Permission, cascades ...onyx.CascadeSpec) ([]Permission, error) { if len(items) == 0 { return nil, nil }; var relationships []string; for i, spec := range cascades { if spec == nil { return nil, fmt.Errorf("cascade spec at index %d is nil", i) }; relationships = append(relationships, spec.String()) }; out := make([]Permission, 0, len(items)); for i, item := range items { ctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, "save_many", Tables.Permission); saved, err := c.core.Save(ctxOp, Tables.Permission, item, relationships); if err != nil { err = fmt.Errorf("failed to save permission at index %d: %w", i, err); done(err); return nil, err }; var decoded Permission; if err := decodeSaved(saved, &decoded); err != nil { err = fmt.Errorf("failed to decode saved permission at index %d: %w", i, err); done(err); return nil, err }; done(nil); out = append(out, decoded) }; return out, nil }
func (c PermissionsClient) DeleteByID(ctx context.Context, id string) (int, error) { if id == "" { return 0, fmt.Errorf("id cannot be empty") }; ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete_by_id", Tables.Permission); err := c.core.Delete(ctx, Tables.Permission, id); if err != nil { err = fmt.Errorf("failed to delete permission %s: %w", id, err); done(err); return 0, err }; done(nil); return 1, nil }
func (c PermissionsClient) DeleteByIDs(ctx context.Context, ids []string) (int, error) { if len(ids) == 0 { return 0, nil }; for i, id := range ids { if id == "" { return 0, fmt.Errorf("id at index %d is empty", i) } }; client := c.Where(onyx.In("id", toAnyStrings(ids))); ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "delete_many", Tables.Permission); n, err := client.q.Delete(ctx); if err != nil { err = fmt.Errorf("failed to delete permission by ids: %w", err); done(err); return 0, err }; done(nil); return n, nil }
func (c PermissionsClient) FindByID(ctx context.Context, id string) (Permission, error) { if id == "" { return Permission{}, fmt.Errorf("id cannot be empty") }; items, err := c.Where(onyx.Eq("id", id)).Limit(1).List(ctx); if err != nil { return Permission{}, fmt.Errorf("failed to find permission by id %s: %w", id, err) }; if len(items) == 0 { return Permission{}, nil }; return items[0], nil }
func (c PermissionsMapClient) Where(cond onyx.Condition) PermissionsMapClient { c.q = c.q.Where(cond); return c }
func (c PermissionsMapClient) And(cond onyx.Condition) PermissionsMapClient { c.q = c.q.And(cond); return c }
func (c PermissionsMapClient) Or(cond onyx.Condition) PermissionsMapClient { c.q = c.q.Or(cond); return c }
func (c PermissionsMapClient) Resolve(resolvers ...string) PermissionsMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c PermissionsMapClient) OrderBy(field string, asc bool) PermissionsMapClient { if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }; return c }
func (c PermissionsMapClient) Limit(n int) PermissionsMapClient { c.q = c.q.Limit(n); return c }
func (c PermissionsMapClient) SetUpdates(updates map[string]any) PermissionsMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c PermissionsMapClient) Select(fields ...string) PermissionsMapClient { c.q = c.q.Select(fields...); return c }
func (c PermissionsMapClient) GroupBy(fields ...string) PermissionsMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c PermissionsMapClient) WithTimeout(d time.Duration) PermissionsMapClient { if d <= 0 { c.timeout = 30 * time.Second; return c }; c.timeout = d; return c }
func (c PermissionsMapClient) WithDefaultTimeout() PermissionsMapClient { return c.WithTimeout(30 * time.Second) }
func (c PermissionsMapClient) WithShortTimeout() PermissionsMapClient { return c.WithTimeout(5 * time.Second) }
func (c PermissionsMapClient) WithLongTimeout() PermissionsMapClient { return c.WithTimeout(2 * time.Minute) }
func (c PermissionsMapClient) WithHook(h QueryHook) PermissionsMapClient { c.hook = h; return c }
func (c PermissionsMapClient) Stream(ctx context.Context) (onyx.Iterator, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.Permission); iter, err := c.q.Stream(ctx); done(err); return iter, err }
func (c PermissionsMapClient) List(ctx context.Context) ([]map[string]any, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.Permission); res := onyx.List(ctx, c.q); var out []map[string]any; if err := res.Decode(&out); err != nil { err = fmt.Errorf("failed to decode permission map list: %w", err); done(err); return nil, err }; done(nil); return out, nil }
func (c PermissionsMapClient) Page(ctx context.Context, cursor string) (PermissionMapPage, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.Permission); res, err := c.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf("failed to page permission maps: %w", err); done(err); return PermissionMapPage{}, err }; if res.Items == nil { done(nil); return PermissionMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil }; done(nil); return PermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil }
func (c PermissionsMapClient) Pages(ctx context.Context) *PermissionsMapPageIterator { return &PermissionsMapPageIterator{client: c, ctx: ctx} }
func (c PermissionsMapClient) Update(ctx context.Context) (int, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.Permission); n, err := c.q.Update(ctx); if err != nil { err = fmt.Errorf("failed to update permission maps: %w", err); done(err); return 0, err }; done(nil); return n, nil }
func (c PermissionsMapClient) Delete(ctx context.Context) (int, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.Permission); n, err := c.q.Delete(ctx); if err != nil { err = fmt.Errorf("failed to delete permission maps: %w", err); done(err); return 0, err }; done(nil); return n, nil }
func (it *PermissionsPageIterator) Next() bool { if it.err != nil { return false }; if !it.started { it.started = true; it.err = it.fetch(""); return it.err == nil }; if it.page.NextCursor == "" { return false }; it.err = it.fetch(it.page.NextCursor); return it.err == nil }
func (it *PermissionsPageIterator) Page() (PermissionPage, error) { if it.err != nil { return PermissionPage{}, it.err }; return it.page, nil }
func (it *PermissionsPageIterator) Err() error { return it.err }
func (it *PermissionsPageIterator) fetch(cursor string) error { ctx := it.ctx; client := it.client; ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.Permission); res, err := client.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf("failed to page permission: %w", err); done(err); return err }; if res.Items == nil { it.page = PermissionPage{Items: []Permission{}, NextCursor: res.NextCursor}; done(nil); return nil }; var items []Permission; if err := decodeList(res.Items, &items); err != nil { err = fmt.Errorf("failed to decode permission page: %w", err); done(err); return err }; it.page = PermissionPage{Items: items, NextCursor: res.NextCursor}; done(nil); return nil }

func (it *PermissionsMapPageIterator) Next() bool { if it.err != nil { return false }; if !it.started { it.started = true; it.err = it.fetch(""); return it.err == nil }; if it.page.NextCursor == "" { return false }; it.err = it.fetch(it.page.NextCursor); return it.err == nil }
func (it *PermissionsMapPageIterator) Page() (PermissionMapPage, error) { if it.err != nil { return PermissionMapPage{}, it.err }; return it.page, nil }
func (it *PermissionsMapPageIterator) Err() error { return it.err }
func (it *PermissionsMapPageIterator) fetch(cursor string) error { ctx := it.ctx; client := it.client; ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.Permission); res, err := client.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf("failed to page permission maps: %w", err); done(err); return err }; if res.Items == nil { it.page = PermissionMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}; done(nil); return nil }; it.page = PermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}; done(nil); return nil }
