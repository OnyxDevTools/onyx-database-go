// Code generated by onyx-gen-go; DO NOT EDIT.
// Generated at: 2026-01-10T00:37:50Z

package onyx

import (
	"context"
	"time"
	"fmt"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type AuditLog struct {
	Action *string `json:"action,omitempty"`
	ActorId *string `json:"actorId,omitempty"`
	Changes map[string]any `json:"changes,omitempty"`
	DateTime time.Time `json:"dateTime,omitempty"`
	ErrorCode *string `json:"errorCode,omitempty"`
	ErrorMessage *string `json:"errorMessage,omitempty"`
	Id string `json:"id,omitempty"`
	Metadata map[string]any `json:"metadata,omitempty"`
	RequestId *string `json:"requestId,omitempty"`
	Resource *string `json:"resource,omitempty"`
	Status *string `json:"status,omitempty"`
	TargetId *string `json:"targetId,omitempty"`
	TenantId *string `json:"tenantId,omitempty"`
}

// AuditLogUpdates provides typed setters for update operations on AuditLog.
type AuditLogUpdates struct { values map[string]any }

func NewAuditLogUpdates() *AuditLogUpdates { return &AuditLogUpdates{values: make(map[string]any)} }

func (u *AuditLogUpdates) SetAction(v *string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["action"] = v
	return u
}

func (u *AuditLogUpdates) SetActorId(v *string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["actorId"] = v
	return u
}

func (u *AuditLogUpdates) SetChanges(v map[string]any) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["changes"] = v
	return u
}

func (u *AuditLogUpdates) SetDateTime(v time.Time) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["dateTime"] = v
	return u
}

func (u *AuditLogUpdates) SetErrorCode(v *string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["errorCode"] = v
	return u
}

func (u *AuditLogUpdates) SetErrorMessage(v *string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["errorMessage"] = v
	return u
}

func (u *AuditLogUpdates) SetId(v string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["id"] = v
	return u
}

func (u *AuditLogUpdates) SetMetadata(v map[string]any) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["metadata"] = v
	return u
}

func (u *AuditLogUpdates) SetRequestId(v *string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["requestId"] = v
	return u
}

func (u *AuditLogUpdates) SetResource(v *string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["resource"] = v
	return u
}

func (u *AuditLogUpdates) SetStatus(v *string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["status"] = v
	return u
}

func (u *AuditLogUpdates) SetTargetId(v *string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["targetId"] = v
	return u
}

func (u *AuditLogUpdates) SetTenantId(v *string) *AuditLogUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["tenantId"] = v
	return u
}

func (u *AuditLogUpdates) valuesMap() map[string]any { return u.values }

type AuditLogPage struct {
	Items []AuditLog `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type AuditLogMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

// AuditLogsClient provides a fluent API for querying and manipulating AuditLog records.
// All methods return a new client instance, allowing for method chaining.
//
// Example:
//   items, err := db.AuditLogs().
//       Where(onyx.Eq("isActive", true)).
//       OrderBy("createdAt", false).
//       Limit(10).
//       List(ctx)
type AuditLogsClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }
// AuditLogsMapClient provides map-based query helpers returned from Select/GroupBy operations.
type AuditLogsMapClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }

// AuditLogRepository captures the full set of AuditLogsClient operations for easy mocking in tests.
type AuditLogRepository interface {
	Where(cond onyx.Condition) AuditLogsClient
	And(cond onyx.Condition) AuditLogsClient
	Or(cond onyx.Condition) AuditLogsClient
	Resolve(resolvers ...string) AuditLogsClient
	OrderBy(field string, asc bool) AuditLogsClient
	Limit(n int) AuditLogsClient
	SetUpdates(updates map[string]any) AuditLogsClient
	SetAuditLogUpdates(updates *AuditLogUpdates) AuditLogsClient
	Select(fields ...string) AuditLogsMapClient
	GroupBy(fields ...string) AuditLogsMapClient
	AsMaps() AuditLogsMapClient
	WithTimeout(d time.Duration) AuditLogsClient
	WithDefaultTimeout() AuditLogsClient
	WithShortTimeout() AuditLogsClient
	WithLongTimeout() AuditLogsClient
	WithHook(h QueryHook) AuditLogsClient
	Stream(ctx context.Context) (onyx.Iterator, error)
	List(ctx context.Context) ([]AuditLog, error)
	ListMaps(ctx context.Context) ([]map[string]any, error)
	Page(ctx context.Context, cursor string) (AuditLogPage, error)
	Pages(ctx context.Context) *AuditLogsPageIterator
	PageOfMaps(ctx context.Context, cursor string) (AuditLogMapPage, error)
	Update(ctx context.Context) (int, error)
	Delete(ctx context.Context) (int, error)
	Save(ctx context.Context, item AuditLog, cascades ...onyx.CascadeSpec) (AuditLog, error)
	SaveMany(ctx context.Context, items []AuditLog, cascades ...onyx.CascadeSpec) ([]AuditLog, error)
	DeleteByID(ctx context.Context, id string) (int, error)
	DeleteByIDs(ctx context.Context, ids []string) (int, error)
	FindByID(ctx context.Context, id string) (AuditLog, error)
}

// AuditLogsPageIterator iterates over paginated AuditLog results.
type AuditLogsPageIterator struct {
	client AuditLogsClient
	ctx context.Context
	cursor string
	started bool
	page AuditLogPage
	err error
}

// AuditLogsMapPageIterator iterates over paginated map results for AuditLog queries.
type AuditLogsMapPageIterator struct {
	client AuditLogsMapClient
	ctx context.Context
	cursor string
	started bool
	page AuditLogMapPage
	err error
}

// AuditLogs returns a typed client scoped to the AuditLog table.
func (c DB) AuditLogs() AuditLogsClient { return AuditLogsClient{core: c.core, q: c.core.From(Tables.AuditLog)} }

func (c AuditLogsClient) Where(cond onyx.Condition) AuditLogsClient { c.q = c.q.Where(cond); return c }
func (c AuditLogsClient) And(cond onyx.Condition) AuditLogsClient { c.q = c.q.And(cond); return c }
func (c AuditLogsClient) Or(cond onyx.Condition) AuditLogsClient { c.q = c.q.Or(cond); return c }
func (c AuditLogsClient) Resolve(resolvers ...string) AuditLogsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c AuditLogsClient) OrderBy(field string, asc bool) AuditLogsClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c AuditLogsClient) Limit(n int) AuditLogsClient { c.q = c.q.Limit(n); return c }
func (c AuditLogsClient) SetUpdates(updates map[string]any) AuditLogsClient { c.q = c.q.SetUpdates(updates); return c }
func (c AuditLogsClient) SetAuditLogUpdates(updates *AuditLogUpdates) AuditLogsClient {
	if updates == nil {
		return c
	}
	c.q = c.q.SetUpdates(updates.valuesMap())
	return c
}
func (c AuditLogsClient) Select(fields ...string) AuditLogsMapClient {
	c.q = c.q.Select(fields...)
	return AuditLogsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c AuditLogsClient) GroupBy(fields ...string) AuditLogsMapClient {
	c.q = c.q.GroupBy(fields...)
	return AuditLogsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c AuditLogsClient) AsMaps() AuditLogsMapClient { return AuditLogsMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c AuditLogsClient) WithTimeout(d time.Duration) AuditLogsClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c AuditLogsClient) WithDefaultTimeout() AuditLogsClient { return c.WithTimeout(30 * time.Second) }
func (c AuditLogsClient) WithShortTimeout() AuditLogsClient { return c.WithTimeout(5 * time.Second) }
func (c AuditLogsClient) WithLongTimeout() AuditLogsClient { return c.WithTimeout(2 * time.Minute) }
func (c AuditLogsClient) WithHook(h QueryHook) AuditLogsClient { c.hook = h; return c }
func (c AuditLogsClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.AuditLog)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c AuditLogsClient) List(ctx context.Context) ([]AuditLog, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list", Tables.AuditLog)
	res := onyx.List(ctx, c.q)
	var out []AuditLog
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode AuditLog list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c AuditLogsClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.AuditLog)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode AuditLog map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c AuditLogsClient) Page(ctx context.Context, cursor string) (AuditLogPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.AuditLog)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page auditlog: %w", err)
		done(err)
		return AuditLogPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return AuditLogPage{Items: []AuditLog{}, NextCursor: res.NextCursor}, nil
	}
	var items []AuditLog
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode auditlog page: %w", err)
		done(err)
		return AuditLogPage{}, err
	}
	done(nil)
	return AuditLogPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c AuditLogsClient) Pages(ctx context.Context) *AuditLogsPageIterator { return &AuditLogsPageIterator{client: c, ctx: ctx} }

func (c AuditLogsClient) PageOfMaps(ctx context.Context, cursor string) (AuditLogMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.AuditLog)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page auditlog maps: %w", err)
		done(err)
		return AuditLogMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return AuditLogMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return AuditLogMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c AuditLogsClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.AuditLog)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update AuditLog: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c AuditLogsClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.AuditLog)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete AuditLog: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c AuditLogsClient) Save(ctx context.Context, item AuditLog, cascades ...onyx.CascadeSpec) (AuditLog, error) {
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return AuditLog{}, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "save", Tables.AuditLog)
	saved, err := c.core.Save(ctx, Tables.AuditLog, item, relationships)
	if err != nil {
		err = fmt.Errorf("failed to save auditlog: %w", err)
		done(err)
		return AuditLog{}, err
	}
	var out AuditLog
	if err := decodeSaved(saved, &out); err != nil {
		err = fmt.Errorf("failed to decode saved auditlog: %w", err)
		done(err)
		return AuditLog{}, err
	}
	done(nil)
	return out, nil
}

func (c AuditLogsClient) SaveMany(ctx context.Context, items []AuditLog, cascades ...onyx.CascadeSpec) ([]AuditLog, error) {
	if len(items) == 0 {
		return nil, nil
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return nil, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	out := make([]AuditLog, 0, len(items))
	for i, item := range items {
		ctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, "save_many", Tables.AuditLog)
		saved, err := c.core.Save(ctxOp, Tables.AuditLog, item, relationships)
		if err != nil {
			err = fmt.Errorf("failed to save auditlog at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		var decoded AuditLog
		if err := decodeSaved(saved, &decoded); err != nil {
			err = fmt.Errorf("failed to decode saved auditlog at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		done(nil)
		out = append(out, decoded)
	}
	return out, nil
}

func (c AuditLogsClient) DeleteByID(ctx context.Context, id string) (int, error) {
	if id == "" {
		return 0, fmt.Errorf("auditlog id cannot be empty")
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete_by_id", Tables.AuditLog)
	err := c.core.Delete(ctx, Tables.AuditLog, id)
	if err != nil {
		err = fmt.Errorf("failed to delete auditlog %s: %w", id, err)
		done(err)
		return 0, err
	}
	done(nil)
	return 1, nil
}

func (c AuditLogsClient) DeleteByIDs(ctx context.Context, ids []string) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	for i, id := range ids {
		if id == "" {
			return 0, fmt.Errorf("id at index %d is empty", i)
		}
	}
	client := c.Where(onyx.In("id", toAnyStrings(ids)))
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "delete_many", Tables.AuditLog)
	n, err := client.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete auditlog by ids: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c AuditLogsClient) FindByID(ctx context.Context, id string) (AuditLog, error) {
	if id == "" {
		return AuditLog{}, fmt.Errorf("auditlog id cannot be empty")
	}
	items, err := c.Where(onyx.Eq("id", id)).Limit(1).List(ctx)
	if err != nil {
		return AuditLog{}, fmt.Errorf("failed to find auditlog by id %s: %w", id, err)
	}
	if len(items) == 0 {
		return AuditLog{}, nil
	}
	return items[0], nil
}

func (c AuditLogsMapClient) Where(cond onyx.Condition) AuditLogsMapClient { c.q = c.q.Where(cond); return c }
func (c AuditLogsMapClient) And(cond onyx.Condition) AuditLogsMapClient { c.q = c.q.And(cond); return c }
func (c AuditLogsMapClient) Or(cond onyx.Condition) AuditLogsMapClient { c.q = c.q.Or(cond); return c }
func (c AuditLogsMapClient) Resolve(resolvers ...string) AuditLogsMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c AuditLogsMapClient) OrderBy(field string, asc bool) AuditLogsMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c AuditLogsMapClient) Limit(n int) AuditLogsMapClient { c.q = c.q.Limit(n); return c }
func (c AuditLogsMapClient) SetUpdates(updates map[string]any) AuditLogsMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c AuditLogsMapClient) Select(fields ...string) AuditLogsMapClient { c.q = c.q.Select(fields...); return c }
func (c AuditLogsMapClient) GroupBy(fields ...string) AuditLogsMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c AuditLogsMapClient) WithTimeout(d time.Duration) AuditLogsMapClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c AuditLogsMapClient) WithDefaultTimeout() AuditLogsMapClient { return c.WithTimeout(30 * time.Second) }
func (c AuditLogsMapClient) WithShortTimeout() AuditLogsMapClient { return c.WithTimeout(5 * time.Second) }
func (c AuditLogsMapClient) WithLongTimeout() AuditLogsMapClient { return c.WithTimeout(2 * time.Minute) }
func (c AuditLogsMapClient) WithHook(h QueryHook) AuditLogsMapClient { c.hook = h; return c }
func (c AuditLogsMapClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.AuditLog)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c AuditLogsMapClient) List(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.AuditLog)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode auditlog map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c AuditLogsMapClient) Page(ctx context.Context, cursor string) (AuditLogMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.AuditLog)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page auditlog maps: %w", err)
		done(err)
		return AuditLogMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return AuditLogMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return AuditLogMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c AuditLogsMapClient) Pages(ctx context.Context) *AuditLogsMapPageIterator { return &AuditLogsMapPageIterator{client: c, ctx: ctx} }

func (c AuditLogsMapClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.AuditLog)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update auditlog maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c AuditLogsMapClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.AuditLog)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete auditlog maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (it *AuditLogsPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *AuditLogsPageIterator) Page() (AuditLogPage, error) {
	if it.err != nil {
		return AuditLogPage{}, it.err
	}
	return it.page, nil
}

func (it *AuditLogsPageIterator) Err() error { return it.err }

func (it *AuditLogsPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.AuditLog)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page auditlog: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = AuditLogPage{Items: []AuditLog{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	var items []AuditLog
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode auditlog page: %w", err)
		done(err)
		return err
	}
	it.page = AuditLogPage{Items: items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

func (it *AuditLogsMapPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *AuditLogsMapPageIterator) Page() (AuditLogMapPage, error) {
	if it.err != nil {
		return AuditLogMapPage{}, it.err
	}
	return it.page, nil
}

func (it *AuditLogsMapPageIterator) Err() error { return it.err }

func (it *AuditLogsMapPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.AuditLog)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page auditlog maps: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = AuditLogMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	it.page = AuditLogMapPage{Items: res.Items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

