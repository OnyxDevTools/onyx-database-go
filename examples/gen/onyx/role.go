// Code generated by onyx gen; DO NOT EDIT.
// Generated at: 2026-01-20T06:44:58Z

package onyx

import (
	"context"
	"time"
	"fmt"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type Role struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	Description *string `json:"description,omitempty"`
	Id *string `json:"id,omitempty"`
	IsSystem *bool `json:"isSystem,omitempty"`
	Name *string `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	Permissions any `json:"permissions,omitempty"`
	RolePermissions any `json:"rolePermissions,omitempty"`
}

// RoleUpdates provides typed setters for update operations on Role.
type RoleUpdates struct { values map[string]any }

func NewRoleUpdates() *RoleUpdates { return &RoleUpdates{values: make(map[string]any)} }

func (u *RoleUpdates) SetCreatedAt(v *time.Time) *RoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["createdAt"] = v
	return u
}

func (u *RoleUpdates) SetDeletedAt(v *time.Time) *RoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["deletedAt"] = v
	return u
}

func (u *RoleUpdates) SetDescription(v *string) *RoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["description"] = v
	return u
}

func (u *RoleUpdates) SetId(v *string) *RoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["id"] = v
	return u
}

func (u *RoleUpdates) SetIsSystem(v *bool) *RoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["isSystem"] = v
	return u
}

func (u *RoleUpdates) SetName(v *string) *RoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["name"] = v
	return u
}

func (u *RoleUpdates) SetUpdatedAt(v *time.Time) *RoleUpdates {
	if u.values == nil { u.values = make(map[string]any) }
	u.values["updatedAt"] = v
	return u
}

func (u *RoleUpdates) valuesMap() map[string]any { return u.values }

type RolePage struct {
	Items []Role `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RoleMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

// RolesClient provides a fluent API for querying and manipulating Role records.
// All methods return a new client instance, allowing for method chaining.
//
// Example:
//   items, err := db.Roles().
//       Where(onyx.Eq("isActive", true)).
//       OrderBy("createdAt", false).
//       Limit(10).
//       List(ctx)
type RolesClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }
// RolesMapClient provides map-based query helpers returned from Select/GroupBy operations.
type RolesMapClient struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }

// RoleRepository captures the full set of RolesClient operations for easy mocking in tests.
type RoleRepository interface {
	Where(cond onyx.Condition) RolesClient
	And(cond onyx.Condition) RolesClient
	Or(cond onyx.Condition) RolesClient
	Resolve(resolvers ...string) RolesClient
	OrderBy(field string, asc bool) RolesClient
	Limit(n int) RolesClient
	SetUpdates(updates map[string]any) RolesClient
	SetRoleUpdates(updates *RoleUpdates) RolesClient
	Select(fields ...string) RolesMapClient
	GroupBy(fields ...string) RolesMapClient
	AsMaps() RolesMapClient
	WithTimeout(d time.Duration) RolesClient
	WithDefaultTimeout() RolesClient
	WithShortTimeout() RolesClient
	WithLongTimeout() RolesClient
	WithHook(h QueryHook) RolesClient
	Stream(ctx context.Context) (onyx.Iterator, error)
	List(ctx context.Context) ([]Role, error)
	ListMaps(ctx context.Context) ([]map[string]any, error)
	Page(ctx context.Context, cursor string) (RolePage, error)
	Pages(ctx context.Context) *RolesPageIterator
	PageOfMaps(ctx context.Context, cursor string) (RoleMapPage, error)
	Update(ctx context.Context) (int, error)
	Delete(ctx context.Context) (int, error)
	Save(ctx context.Context, item Role, cascades ...onyx.CascadeSpec) (Role, error)
	SaveMany(ctx context.Context, items []Role, cascades ...onyx.CascadeSpec) ([]Role, error)
	DeleteByID(ctx context.Context, id string) (int, error)
	DeleteByIDs(ctx context.Context, ids []string) (int, error)
	FindByID(ctx context.Context, id string) (Role, error)
}

// RolesPageIterator iterates over paginated Role results.
type RolesPageIterator struct {
	client RolesClient
	ctx context.Context
	cursor string
	started bool
	page RolePage
	err error
}

// RolesMapPageIterator iterates over paginated map results for Role queries.
type RolesMapPageIterator struct {
	client RolesMapClient
	ctx context.Context
	cursor string
	started bool
	page RoleMapPage
	err error
}

// Roles returns a typed client scoped to the Role table.
func (c DB) Roles() RolesClient { return RolesClient{core: c.core, q: c.core.From(Tables.Role)} }

func (c RolesClient) Where(cond onyx.Condition) RolesClient { c.q = c.q.Where(cond); return c }
func (c RolesClient) And(cond onyx.Condition) RolesClient { c.q = c.q.And(cond); return c }
func (c RolesClient) Or(cond onyx.Condition) RolesClient { c.q = c.q.Or(cond); return c }
func (c RolesClient) Resolve(resolvers ...string) RolesClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolesClient) OrderBy(field string, asc bool) RolesClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolesClient) Limit(n int) RolesClient { c.q = c.q.Limit(n); return c }
func (c RolesClient) SetUpdates(updates map[string]any) RolesClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolesClient) SetRoleUpdates(updates *RoleUpdates) RolesClient {
	if updates == nil {
		return c
	}
	c.q = c.q.SetUpdates(updates.valuesMap())
	return c
}
func (c RolesClient) Select(fields ...string) RolesMapClient {
	c.q = c.q.Select(fields...)
	return RolesMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c RolesClient) GroupBy(fields ...string) RolesMapClient {
	c.q = c.q.GroupBy(fields...)
	return RolesMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook}
}
func (c RolesClient) AsMaps() RolesMapClient { return RolesMapClient{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }
func (c RolesClient) WithTimeout(d time.Duration) RolesClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c RolesClient) WithDefaultTimeout() RolesClient { return c.WithTimeout(30 * time.Second) }
func (c RolesClient) WithShortTimeout() RolesClient { return c.WithTimeout(5 * time.Second) }
func (c RolesClient) WithLongTimeout() RolesClient { return c.WithTimeout(2 * time.Minute) }
func (c RolesClient) WithHook(h QueryHook) RolesClient { c.hook = h; return c }
func (c RolesClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.Role)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c RolesClient) List(ctx context.Context) ([]Role, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list", Tables.Role)
	res := onyx.List(ctx, c.q)
	var out []Role
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode Role list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c RolesClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.Role)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode Role map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c RolesClient) Page(ctx context.Context, cursor string) (RolePage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.Role)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page role: %w", err)
		done(err)
		return RolePage{}, err
	}
	if res.Items == nil {
		done(nil)
		return RolePage{Items: []Role{}, NextCursor: res.NextCursor}, nil
	}
	var items []Role
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode role page: %w", err)
		done(err)
		return RolePage{}, err
	}
	done(nil)
	return RolePage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c RolesClient) Pages(ctx context.Context) *RolesPageIterator { return &RolesPageIterator{client: c, ctx: ctx} }

func (c RolesClient) PageOfMaps(ctx context.Context, cursor string) (RoleMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.Role)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page role maps: %w", err)
		done(err)
		return RoleMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return RoleMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return RoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolesClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.Role)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update Role: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c RolesClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.Role)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete Role: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c RolesClient) Save(ctx context.Context, item Role, cascades ...onyx.CascadeSpec) (Role, error) {
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return Role{}, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "save", Tables.Role)
	saved, err := c.core.Save(ctx, Tables.Role, item, relationships)
	if err != nil {
		err = fmt.Errorf("failed to save role: %w", err)
		done(err)
		return Role{}, err
	}
	var out Role
	if err := decodeSaved(saved, &out); err != nil {
		err = fmt.Errorf("failed to decode saved role: %w", err)
		done(err)
		return Role{}, err
	}
	done(nil)
	return out, nil
}

func (c RolesClient) SaveMany(ctx context.Context, items []Role, cascades ...onyx.CascadeSpec) ([]Role, error) {
	if len(items) == 0 {
		return nil, nil
	}
	var relationships []string
	for i, spec := range cascades {
		if spec == nil {
			return nil, fmt.Errorf("cascade spec at index %d is nil", i)
		}
		relationships = append(relationships, spec.String())
	}
	out := make([]Role, 0, len(items))
	for i, item := range items {
		ctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, "save_many", Tables.Role)
		saved, err := c.core.Save(ctxOp, Tables.Role, item, relationships)
		if err != nil {
			err = fmt.Errorf("failed to save role at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		var decoded Role
		if err := decodeSaved(saved, &decoded); err != nil {
			err = fmt.Errorf("failed to decode saved role at index %d: %w", i, err)
			done(err)
			return nil, err
		}
		done(nil)
		out = append(out, decoded)
	}
	return out, nil
}

func (c RolesClient) DeleteByID(ctx context.Context, id string) (int, error) {
	if id == "" {
		return 0, fmt.Errorf("role id cannot be empty")
	}
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete_by_id", Tables.Role)
	err := c.core.Delete(ctx, Tables.Role, id)
	if err != nil {
		err = fmt.Errorf("failed to delete role %s: %w", id, err)
		done(err)
		return 0, err
	}
	done(nil)
	return 1, nil
}

func (c RolesClient) DeleteByIDs(ctx context.Context, ids []string) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}
	for i, id := range ids {
		if id == "" {
			return 0, fmt.Errorf("id at index %d is empty", i)
		}
	}
	client := c.Where(onyx.In("id", toAnyStrings(ids)))
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "delete_many", Tables.Role)
	n, err := client.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete role by ids: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c RolesClient) FindByID(ctx context.Context, id string) (Role, error) {
	if id == "" {
		return Role{}, fmt.Errorf("role id cannot be empty")
	}
	items, err := c.Where(onyx.Eq("id", id)).Limit(1).List(ctx)
	if err != nil {
		return Role{}, fmt.Errorf("failed to find role by id %s: %w", id, err)
	}
	if len(items) == 0 {
		return Role{}, nil
	}
	return items[0], nil
}

func (c RolesMapClient) Where(cond onyx.Condition) RolesMapClient { c.q = c.q.Where(cond); return c }
func (c RolesMapClient) And(cond onyx.Condition) RolesMapClient { c.q = c.q.And(cond); return c }
func (c RolesMapClient) Or(cond onyx.Condition) RolesMapClient { c.q = c.q.Or(cond); return c }
func (c RolesMapClient) Resolve(resolvers ...string) RolesMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolesMapClient) OrderBy(field string, asc bool) RolesMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolesMapClient) Limit(n int) RolesMapClient { c.q = c.q.Limit(n); return c }
func (c RolesMapClient) SetUpdates(updates map[string]any) RolesMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolesMapClient) Select(fields ...string) RolesMapClient { c.q = c.q.Select(fields...); return c }
func (c RolesMapClient) GroupBy(fields ...string) RolesMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c RolesMapClient) WithTimeout(d time.Duration) RolesMapClient {
	if d <= 0 {
		c.timeout = 30 * time.Second
		return c
	}
	c.timeout = d
	return c
}
func (c RolesMapClient) WithDefaultTimeout() RolesMapClient { return c.WithTimeout(30 * time.Second) }
func (c RolesMapClient) WithShortTimeout() RolesMapClient { return c.WithTimeout(5 * time.Second) }
func (c RolesMapClient) WithLongTimeout() RolesMapClient { return c.WithTimeout(2 * time.Minute) }
func (c RolesMapClient) WithHook(h QueryHook) RolesMapClient { c.hook = h; return c }
func (c RolesMapClient) Stream(ctx context.Context) (onyx.Iterator, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "stream", Tables.Role)
	iter, err := c.q.Stream(ctx)
	done(err)
	return iter, err
}
func (c RolesMapClient) List(ctx context.Context) ([]map[string]any, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "list_maps", Tables.Role)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	err := res.Decode(&out)
	if err != nil {
		err = fmt.Errorf("failed to decode role map list: %w", err)
		done(err)
		return nil, err
	}
	done(nil)
	return out, nil
}

func (c RolesMapClient) Page(ctx context.Context, cursor string) (RoleMapPage, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "page", Tables.Role)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page role maps: %w", err)
		done(err)
		return RoleMapPage{}, err
	}
	if res.Items == nil {
		done(nil)
		return RoleMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil
	}
	done(nil)
	return RoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolesMapClient) Pages(ctx context.Context) *RolesMapPageIterator { return &RolesMapPageIterator{client: c, ctx: ctx} }

func (c RolesMapClient) Update(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "update", Tables.Role)
	n, err := c.q.Update(ctx)
	if err != nil {
		err = fmt.Errorf("failed to update role maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (c RolesMapClient) Delete(ctx context.Context) (int, error) {
	ctx, done := withContextAndHook(ctx, c.timeout, c.hook, "delete", Tables.Role)
	n, err := c.q.Delete(ctx)
	if err != nil {
		err = fmt.Errorf("failed to delete role maps: %w", err)
		done(err)
		return 0, err
	}
	done(nil)
	return n, nil
}

func (it *RolesPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *RolesPageIterator) Page() (RolePage, error) {
	if it.err != nil {
		return RolePage{}, it.err
	}
	return it.page, nil
}

func (it *RolesPageIterator) Err() error { return it.err }

func (it *RolesPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.Role)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page role: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = RolePage{Items: []Role{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	var items []Role
	if err := decodeList(res.Items, &items); err != nil {
		err = fmt.Errorf("failed to decode role page: %w", err)
		done(err)
		return err
	}
	it.page = RolePage{Items: items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

func (it *RolesMapPageIterator) Next() bool {
	if it.err != nil {
		return false
	}
	if !it.started {
		it.started = true
		it.err = it.fetch("")
		return it.err == nil
	}
	if it.page.NextCursor == "" {
		return false
	}
	it.err = it.fetch(it.page.NextCursor)
	return it.err == nil
}

func (it *RolesMapPageIterator) Page() (RoleMapPage, error) {
	if it.err != nil {
		return RoleMapPage{}, it.err
	}
	return it.page, nil
}

func (it *RolesMapPageIterator) Err() error { return it.err }

func (it *RolesMapPageIterator) fetch(cursor string) error {
	ctx := it.ctx
	client := it.client
	ctx, done := withContextAndHook(ctx, client.timeout, client.hook, "page", Tables.Role)
	res, err := client.q.Page(ctx, cursor)
	if err != nil {
		err = fmt.Errorf("failed to page role maps: %w", err)
		done(err)
		return err
	}
	if res.Items == nil {
		it.page = RoleMapPage{Items: []map[string]any{}, NextCursor: res.NextCursor}
		done(nil)
		return nil
	}
	it.page = RoleMapPage{Items: res.Items, NextCursor: res.NextCursor}
	done(nil)
	return nil
}

