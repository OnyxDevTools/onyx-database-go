// Code generated by onyx-gen-go; DO NOT EDIT.

package onyxclient

import (
	"context"
	"encoding/json"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type Client struct { core onyx.Client }

func NewClient(core onyx.Client) Client { return Client{core: core} }

func (c Client) Core() onyx.Client { return c.core }

type AuditLogPage struct {
	Items []AuditLog `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type AuditLogMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type AuditLogsClient struct { core onyx.Client; ctx context.Context; q onyx.Query }

func (c Client) AuditLogs(ctx context.Context) AuditLogsClient { return AuditLogsClient{core: c.core, ctx: ctx, q: c.core.From(Tables.AuditLog)} }

func (c AuditLogsClient) WithContext(ctx context.Context) AuditLogsClient { c.ctx = ctx; return c }
func (c AuditLogsClient) Where(cond onyx.Condition) AuditLogsClient { c.q = c.q.Where(cond); return c }
func (c AuditLogsClient) And(cond onyx.Condition) AuditLogsClient { c.q = c.q.And(cond); return c }
func (c AuditLogsClient) Or(cond onyx.Condition) AuditLogsClient { c.q = c.q.Or(cond); return c }
func (c AuditLogsClient) Resolve(resolvers ...string) AuditLogsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c AuditLogsClient) OrderBy(field string, asc bool) AuditLogsClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c AuditLogsClient) Limit(n int) AuditLogsClient { c.q = c.q.Limit(n); return c }
func (c AuditLogsClient) Select(fields ...string) AuditLogsClient { c.q = c.q.Select(fields...); return c }
func (c AuditLogsClient) GroupBy(fields ...string) AuditLogsClient { c.q = c.q.GroupBy(fields...); return c }
func (c AuditLogsClient) SetUpdates(updates map[string]any) AuditLogsClient { c.q = c.q.SetUpdates(updates); return c }
func (c AuditLogsClient) Stream(ctx context.Context) (onyx.Iterator, error) { ctx = useContext(ctx, c.ctx); return c.q.Stream(ctx) }
func (c AuditLogsClient) List(ctx context.Context) ([]AuditLog, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []AuditLog
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c AuditLogsClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c AuditLogsClient) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c AuditLogsClient) Page(ctx context.Context, cursor string) (AuditLogPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return AuditLogPage{}, err
	}
	var items []AuditLog
	if err := decodeList(res.Items, &items); err != nil {
		return AuditLogPage{}, err
	}
	return AuditLogPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c AuditLogsClient) PageOfMaps(ctx context.Context, cursor string) (AuditLogMapPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return AuditLogMapPage{}, err
	}
	return AuditLogMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c AuditLogsClient) Update(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Update(ctx) }

func (c AuditLogsClient) Delete(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Delete(ctx) }

func (c AuditLogsClient) Save(item AuditLog, cascades ...onyx.CascadeSpec) (AuditLog, error) {
	ctx := useContext(nil, c.ctx)
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.AuditLog, item, relationships)
	if err != nil {
		return AuditLog{}, err
	}
	var out AuditLog
	if err := decodeSaved(saved, &out); err != nil {
		return AuditLog{}, err
	}
	return out, nil
}

func (c AuditLogsClient) DeleteByID(id string) error {
	ctx := useContext(nil, c.ctx)
	return c.core.Delete(ctx, Tables.AuditLog, id)
}

type PermissionPage struct {
	Items []Permission `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type PermissionMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type PermissionsClient struct { core onyx.Client; ctx context.Context; q onyx.Query }

func (c Client) Permissions(ctx context.Context) PermissionsClient { return PermissionsClient{core: c.core, ctx: ctx, q: c.core.From(Tables.Permission)} }

func (c PermissionsClient) WithContext(ctx context.Context) PermissionsClient { c.ctx = ctx; return c }
func (c PermissionsClient) Where(cond onyx.Condition) PermissionsClient { c.q = c.q.Where(cond); return c }
func (c PermissionsClient) And(cond onyx.Condition) PermissionsClient { c.q = c.q.And(cond); return c }
func (c PermissionsClient) Or(cond onyx.Condition) PermissionsClient { c.q = c.q.Or(cond); return c }
func (c PermissionsClient) Resolve(resolvers ...string) PermissionsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c PermissionsClient) OrderBy(field string, asc bool) PermissionsClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c PermissionsClient) Limit(n int) PermissionsClient { c.q = c.q.Limit(n); return c }
func (c PermissionsClient) Select(fields ...string) PermissionsClient { c.q = c.q.Select(fields...); return c }
func (c PermissionsClient) GroupBy(fields ...string) PermissionsClient { c.q = c.q.GroupBy(fields...); return c }
func (c PermissionsClient) SetUpdates(updates map[string]any) PermissionsClient { c.q = c.q.SetUpdates(updates); return c }
func (c PermissionsClient) Stream(ctx context.Context) (onyx.Iterator, error) { ctx = useContext(ctx, c.ctx); return c.q.Stream(ctx) }
func (c PermissionsClient) List(ctx context.Context) ([]Permission, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []Permission
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c PermissionsClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c PermissionsClient) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c PermissionsClient) Page(ctx context.Context, cursor string) (PermissionPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return PermissionPage{}, err
	}
	var items []Permission
	if err := decodeList(res.Items, &items); err != nil {
		return PermissionPage{}, err
	}
	return PermissionPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c PermissionsClient) PageOfMaps(ctx context.Context, cursor string) (PermissionMapPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return PermissionMapPage{}, err
	}
	return PermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c PermissionsClient) Update(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Update(ctx) }

func (c PermissionsClient) Delete(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Delete(ctx) }

func (c PermissionsClient) Save(item Permission, cascades ...onyx.CascadeSpec) (Permission, error) {
	ctx := useContext(nil, c.ctx)
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.Permission, item, relationships)
	if err != nil {
		return Permission{}, err
	}
	var out Permission
	if err := decodeSaved(saved, &out); err != nil {
		return Permission{}, err
	}
	return out, nil
}

func (c PermissionsClient) DeleteByID(id string) error {
	ctx := useContext(nil, c.ctx)
	return c.core.Delete(ctx, Tables.Permission, id)
}

type RolePage struct {
	Items []Role `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RoleMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RolesClient struct { core onyx.Client; ctx context.Context; q onyx.Query }

func (c Client) Roles(ctx context.Context) RolesClient { return RolesClient{core: c.core, ctx: ctx, q: c.core.From(Tables.Role)} }

func (c RolesClient) WithContext(ctx context.Context) RolesClient { c.ctx = ctx; return c }
func (c RolesClient) Where(cond onyx.Condition) RolesClient { c.q = c.q.Where(cond); return c }
func (c RolesClient) And(cond onyx.Condition) RolesClient { c.q = c.q.And(cond); return c }
func (c RolesClient) Or(cond onyx.Condition) RolesClient { c.q = c.q.Or(cond); return c }
func (c RolesClient) Resolve(resolvers ...string) RolesClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolesClient) OrderBy(field string, asc bool) RolesClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolesClient) Limit(n int) RolesClient { c.q = c.q.Limit(n); return c }
func (c RolesClient) Select(fields ...string) RolesClient { c.q = c.q.Select(fields...); return c }
func (c RolesClient) GroupBy(fields ...string) RolesClient { c.q = c.q.GroupBy(fields...); return c }
func (c RolesClient) SetUpdates(updates map[string]any) RolesClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolesClient) Stream(ctx context.Context) (onyx.Iterator, error) { ctx = useContext(ctx, c.ctx); return c.q.Stream(ctx) }
func (c RolesClient) List(ctx context.Context) ([]Role, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []Role
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolesClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolesClient) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolesClient) Page(ctx context.Context, cursor string) (RolePage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RolePage{}, err
	}
	var items []Role
	if err := decodeList(res.Items, &items); err != nil {
		return RolePage{}, err
	}
	return RolePage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c RolesClient) PageOfMaps(ctx context.Context, cursor string) (RoleMapPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RoleMapPage{}, err
	}
	return RoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolesClient) Update(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Update(ctx) }

func (c RolesClient) Delete(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Delete(ctx) }

func (c RolesClient) Save(item Role, cascades ...onyx.CascadeSpec) (Role, error) {
	ctx := useContext(nil, c.ctx)
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.Role, item, relationships)
	if err != nil {
		return Role{}, err
	}
	var out Role
	if err := decodeSaved(saved, &out); err != nil {
		return Role{}, err
	}
	return out, nil
}

func (c RolesClient) DeleteByID(id string) error {
	ctx := useContext(nil, c.ctx)
	return c.core.Delete(ctx, Tables.Role, id)
}

type RolePermissionPage struct {
	Items []RolePermission `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RolePermissionMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RolePermissionsClient struct { core onyx.Client; ctx context.Context; q onyx.Query }

func (c Client) RolePermissions(ctx context.Context) RolePermissionsClient { return RolePermissionsClient{core: c.core, ctx: ctx, q: c.core.From(Tables.RolePermission)} }

func (c RolePermissionsClient) WithContext(ctx context.Context) RolePermissionsClient { c.ctx = ctx; return c }
func (c RolePermissionsClient) Where(cond onyx.Condition) RolePermissionsClient { c.q = c.q.Where(cond); return c }
func (c RolePermissionsClient) And(cond onyx.Condition) RolePermissionsClient { c.q = c.q.And(cond); return c }
func (c RolePermissionsClient) Or(cond onyx.Condition) RolePermissionsClient { c.q = c.q.Or(cond); return c }
func (c RolePermissionsClient) Resolve(resolvers ...string) RolePermissionsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolePermissionsClient) OrderBy(field string, asc bool) RolePermissionsClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolePermissionsClient) Limit(n int) RolePermissionsClient { c.q = c.q.Limit(n); return c }
func (c RolePermissionsClient) Select(fields ...string) RolePermissionsClient { c.q = c.q.Select(fields...); return c }
func (c RolePermissionsClient) GroupBy(fields ...string) RolePermissionsClient { c.q = c.q.GroupBy(fields...); return c }
func (c RolePermissionsClient) SetUpdates(updates map[string]any) RolePermissionsClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolePermissionsClient) Stream(ctx context.Context) (onyx.Iterator, error) { ctx = useContext(ctx, c.ctx); return c.q.Stream(ctx) }
func (c RolePermissionsClient) List(ctx context.Context) ([]RolePermission, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []RolePermission
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolePermissionsClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolePermissionsClient) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolePermissionsClient) Page(ctx context.Context, cursor string) (RolePermissionPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RolePermissionPage{}, err
	}
	var items []RolePermission
	if err := decodeList(res.Items, &items); err != nil {
		return RolePermissionPage{}, err
	}
	return RolePermissionPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c RolePermissionsClient) PageOfMaps(ctx context.Context, cursor string) (RolePermissionMapPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RolePermissionMapPage{}, err
	}
	return RolePermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolePermissionsClient) Update(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Update(ctx) }

func (c RolePermissionsClient) Delete(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Delete(ctx) }

func (c RolePermissionsClient) Save(item RolePermission, cascades ...onyx.CascadeSpec) (RolePermission, error) {
	ctx := useContext(nil, c.ctx)
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.RolePermission, item, relationships)
	if err != nil {
		return RolePermission{}, err
	}
	var out RolePermission
	if err := decodeSaved(saved, &out); err != nil {
		return RolePermission{}, err
	}
	return out, nil
}

func (c RolePermissionsClient) DeleteByID(id string) error {
	ctx := useContext(nil, c.ctx)
	return c.core.Delete(ctx, Tables.RolePermission, id)
}

type UserPage struct {
	Items []User `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UsersClient struct { core onyx.Client; ctx context.Context; q onyx.Query }

func (c Client) Users(ctx context.Context) UsersClient { return UsersClient{core: c.core, ctx: ctx, q: c.core.From(Tables.User)} }

func (c UsersClient) WithContext(ctx context.Context) UsersClient { c.ctx = ctx; return c }
func (c UsersClient) Where(cond onyx.Condition) UsersClient { c.q = c.q.Where(cond); return c }
func (c UsersClient) And(cond onyx.Condition) UsersClient { c.q = c.q.And(cond); return c }
func (c UsersClient) Or(cond onyx.Condition) UsersClient { c.q = c.q.Or(cond); return c }
func (c UsersClient) Resolve(resolvers ...string) UsersClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UsersClient) OrderBy(field string, asc bool) UsersClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UsersClient) Limit(n int) UsersClient { c.q = c.q.Limit(n); return c }
func (c UsersClient) Select(fields ...string) UsersClient { c.q = c.q.Select(fields...); return c }
func (c UsersClient) GroupBy(fields ...string) UsersClient { c.q = c.q.GroupBy(fields...); return c }
func (c UsersClient) SetUpdates(updates map[string]any) UsersClient { c.q = c.q.SetUpdates(updates); return c }
func (c UsersClient) Stream(ctx context.Context) (onyx.Iterator, error) { ctx = useContext(ctx, c.ctx); return c.q.Stream(ctx) }
func (c UsersClient) List(ctx context.Context) ([]User, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []User
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UsersClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UsersClient) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UsersClient) Page(ctx context.Context, cursor string) (UserPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserPage{}, err
	}
	var items []User
	if err := decodeList(res.Items, &items); err != nil {
		return UserPage{}, err
	}
	return UserPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c UsersClient) PageOfMaps(ctx context.Context, cursor string) (UserMapPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserMapPage{}, err
	}
	return UserMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UsersClient) Update(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Update(ctx) }

func (c UsersClient) Delete(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Delete(ctx) }

func (c UsersClient) Save(item User, cascades ...onyx.CascadeSpec) (User, error) {
	ctx := useContext(nil, c.ctx)
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.User, item, relationships)
	if err != nil {
		return User{}, err
	}
	var out User
	if err := decodeSaved(saved, &out); err != nil {
		return User{}, err
	}
	return out, nil
}

func (c UsersClient) DeleteByID(id string) error {
	ctx := useContext(nil, c.ctx)
	return c.core.Delete(ctx, Tables.User, id)
}

type UserProfilePage struct {
	Items []UserProfile `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserProfileMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserProfilesClient struct { core onyx.Client; ctx context.Context; q onyx.Query }

func (c Client) UserProfiles(ctx context.Context) UserProfilesClient { return UserProfilesClient{core: c.core, ctx: ctx, q: c.core.From(Tables.UserProfile)} }

func (c UserProfilesClient) WithContext(ctx context.Context) UserProfilesClient { c.ctx = ctx; return c }
func (c UserProfilesClient) Where(cond onyx.Condition) UserProfilesClient { c.q = c.q.Where(cond); return c }
func (c UserProfilesClient) And(cond onyx.Condition) UserProfilesClient { c.q = c.q.And(cond); return c }
func (c UserProfilesClient) Or(cond onyx.Condition) UserProfilesClient { c.q = c.q.Or(cond); return c }
func (c UserProfilesClient) Resolve(resolvers ...string) UserProfilesClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserProfilesClient) OrderBy(field string, asc bool) UserProfilesClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserProfilesClient) Limit(n int) UserProfilesClient { c.q = c.q.Limit(n); return c }
func (c UserProfilesClient) Select(fields ...string) UserProfilesClient { c.q = c.q.Select(fields...); return c }
func (c UserProfilesClient) GroupBy(fields ...string) UserProfilesClient { c.q = c.q.GroupBy(fields...); return c }
func (c UserProfilesClient) SetUpdates(updates map[string]any) UserProfilesClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserProfilesClient) Stream(ctx context.Context) (onyx.Iterator, error) { ctx = useContext(ctx, c.ctx); return c.q.Stream(ctx) }
func (c UserProfilesClient) List(ctx context.Context) ([]UserProfile, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []UserProfile
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserProfilesClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserProfilesClient) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserProfilesClient) Page(ctx context.Context, cursor string) (UserProfilePage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserProfilePage{}, err
	}
	var items []UserProfile
	if err := decodeList(res.Items, &items); err != nil {
		return UserProfilePage{}, err
	}
	return UserProfilePage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c UserProfilesClient) PageOfMaps(ctx context.Context, cursor string) (UserProfileMapPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserProfileMapPage{}, err
	}
	return UserProfileMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserProfilesClient) Update(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Update(ctx) }

func (c UserProfilesClient) Delete(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Delete(ctx) }

func (c UserProfilesClient) Save(item UserProfile, cascades ...onyx.CascadeSpec) (UserProfile, error) {
	ctx := useContext(nil, c.ctx)
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.UserProfile, item, relationships)
	if err != nil {
		return UserProfile{}, err
	}
	var out UserProfile
	if err := decodeSaved(saved, &out); err != nil {
		return UserProfile{}, err
	}
	return out, nil
}

func (c UserProfilesClient) DeleteByID(id string) error {
	ctx := useContext(nil, c.ctx)
	return c.core.Delete(ctx, Tables.UserProfile, id)
}

type UserRolePage struct {
	Items []UserRole `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserRoleMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserRolesClient struct { core onyx.Client; ctx context.Context; q onyx.Query }

func (c Client) UserRoles(ctx context.Context) UserRolesClient { return UserRolesClient{core: c.core, ctx: ctx, q: c.core.From(Tables.UserRole)} }

func (c UserRolesClient) WithContext(ctx context.Context) UserRolesClient { c.ctx = ctx; return c }
func (c UserRolesClient) Where(cond onyx.Condition) UserRolesClient { c.q = c.q.Where(cond); return c }
func (c UserRolesClient) And(cond onyx.Condition) UserRolesClient { c.q = c.q.And(cond); return c }
func (c UserRolesClient) Or(cond onyx.Condition) UserRolesClient { c.q = c.q.Or(cond); return c }
func (c UserRolesClient) Resolve(resolvers ...string) UserRolesClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserRolesClient) OrderBy(field string, asc bool) UserRolesClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserRolesClient) Limit(n int) UserRolesClient { c.q = c.q.Limit(n); return c }
func (c UserRolesClient) Select(fields ...string) UserRolesClient { c.q = c.q.Select(fields...); return c }
func (c UserRolesClient) GroupBy(fields ...string) UserRolesClient { c.q = c.q.GroupBy(fields...); return c }
func (c UserRolesClient) SetUpdates(updates map[string]any) UserRolesClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserRolesClient) Stream(ctx context.Context) (onyx.Iterator, error) { ctx = useContext(ctx, c.ctx); return c.q.Stream(ctx) }
func (c UserRolesClient) List(ctx context.Context) ([]UserRole, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []UserRole
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserRolesClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserRolesClient) ListAggregates(ctx context.Context) ([]map[string]any, error) {
	ctx = useContext(ctx, c.ctx)
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserRolesClient) Page(ctx context.Context, cursor string) (UserRolePage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserRolePage{}, err
	}
	var items []UserRole
	if err := decodeList(res.Items, &items); err != nil {
		return UserRolePage{}, err
	}
	return UserRolePage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c UserRolesClient) PageOfMaps(ctx context.Context, cursor string) (UserRoleMapPage, error) {
	ctx = useContext(ctx, c.ctx)
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserRoleMapPage{}, err
	}
	return UserRoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserRolesClient) Update(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Update(ctx) }

func (c UserRolesClient) Delete(ctx context.Context) (int, error) { ctx = useContext(ctx, c.ctx); return c.q.Delete(ctx) }

func (c UserRolesClient) Save(item UserRole, cascades ...onyx.CascadeSpec) (UserRole, error) {
	ctx := useContext(nil, c.ctx)
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.UserRole, item, relationships)
	if err != nil {
		return UserRole{}, err
	}
	var out UserRole
	if err := decodeSaved(saved, &out); err != nil {
		return UserRole{}, err
	}
	return out, nil
}

func (c UserRolesClient) DeleteByID(id string) error {
	ctx := useContext(nil, c.ctx)
	return c.core.Delete(ctx, Tables.UserRole, id)
}

func decodeSaved(saved map[string]any, out any) error {
	b, err := json.Marshal(saved)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, out)
}

func decodeList(items []map[string]any, out any) error {
	b, err := json.Marshal(items)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, out)
}

func useContext(ctx, fallback context.Context) context.Context {
	if ctx != nil {
		return ctx
	}
	return fallback
}

type DocumentsClient struct { core onyx.DocumentClient }

func (c Client) Documents() DocumentsClient { return DocumentsClient{core: c.core.Documents()} }

func (d DocumentsClient) List(ctx context.Context) ([]onyx.Document, error) { return d.core.List(ctx) }
func (d DocumentsClient) Get(ctx context.Context, id string) (onyx.Document, error) { return d.core.Get(ctx, id) }
func (d DocumentsClient) Save(ctx context.Context, doc onyx.Document) (onyx.Document, error) { return d.core.Save(ctx, doc) }
func (d DocumentsClient) Delete(ctx context.Context, id string) error { return d.core.Delete(ctx, id) }

type SecretsClient struct { core onyx.Client }

func (c Client) Secrets() SecretsClient { return SecretsClient{core: c.core} }

func (s SecretsClient) List(ctx context.Context) ([]onyx.Secret, error) { return s.core.ListSecrets(ctx) }
func (s SecretsClient) Get(ctx context.Context, key string) (onyx.Secret, error) { return s.core.GetSecret(ctx, key) }
func (s SecretsClient) Set(ctx context.Context, secret onyx.Secret) (onyx.Secret, error) { return s.core.PutSecret(ctx, secret) }
func (s SecretsClient) Delete(ctx context.Context, key string) error { return s.core.DeleteSecret(ctx, key) }

