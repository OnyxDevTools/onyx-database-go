// Code generated by onyx-gen-go; DO NOT EDIT.

package onyxdb

import (
	"context"
	"encoding/json"
	"github.com/OnyxDevTools/onyx-database-go/onyx"
)

type DB struct { core onyx.Client }

type Config = onyx.Config

func New(ctx context.Context, cfg Config) (DB, error) {
	core, err := onyx.Init(ctx, cfg)
	if err != nil {
		return DB{}, err
	}
	return DB{core: core}, nil
}

func Wrap(core onyx.Client) DB { return DB{core: core} }

func (c DB) Core() onyx.Client { return c.core }

type AuditLogPage struct {
	Items []AuditLog `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type AuditLogMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type AuditLogsClient struct { core onyx.Client; q onyx.Query }
type AuditLogsMapClient struct { core onyx.Client; q onyx.Query }

func (c DB) AuditLogs() AuditLogsClient { return AuditLogsClient{core: c.core, q: c.core.From(Tables.AuditLog)} }

func (c AuditLogsClient) Where(cond onyx.Condition) AuditLogsClient { c.q = c.q.Where(cond); return c }
func (c AuditLogsClient) And(cond onyx.Condition) AuditLogsClient { c.q = c.q.And(cond); return c }
func (c AuditLogsClient) Or(cond onyx.Condition) AuditLogsClient { c.q = c.q.Or(cond); return c }
func (c AuditLogsClient) Resolve(resolvers ...string) AuditLogsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c AuditLogsClient) OrderBy(field string, asc bool) AuditLogsClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c AuditLogsClient) Limit(n int) AuditLogsClient { c.q = c.q.Limit(n); return c }
func (c AuditLogsClient) SetUpdates(updates map[string]any) AuditLogsClient { c.q = c.q.SetUpdates(updates); return c }
func (c AuditLogsClient) Select(fields ...string) AuditLogsMapClient {
	c.q = c.q.Select(fields...)
	return AuditLogsMapClient{core: c.core, q: c.q}
}
func (c AuditLogsClient) GroupBy(fields ...string) AuditLogsMapClient {
	c.q = c.q.GroupBy(fields...)
	return AuditLogsMapClient{core: c.core, q: c.q}
}
func (c AuditLogsClient) AsMaps() AuditLogsMapClient { return AuditLogsMapClient{core: c.core, q: c.q} }
func (c AuditLogsClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c AuditLogsClient) List(ctx context.Context) ([]AuditLog, error) {
	res := onyx.List(ctx, c.q)
	var out []AuditLog
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c AuditLogsClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c AuditLogsClient) Page(ctx context.Context, cursor string) (AuditLogPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return AuditLogPage{}, err
	}
	var items []AuditLog
	if err := decodeList(res.Items, &items); err != nil {
		return AuditLogPage{}, err
	}
	return AuditLogPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c AuditLogsClient) PageOfMaps(ctx context.Context, cursor string) (AuditLogMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return AuditLogMapPage{}, err
	}
	return AuditLogMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c AuditLogsClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c AuditLogsClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

func (c AuditLogsClient) Save(ctx context.Context, item AuditLog, cascades ...onyx.CascadeSpec) (AuditLog, error) {
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.AuditLog, item, relationships)
	if err != nil {
		return AuditLog{}, err
	}
	var out AuditLog
	if err := decodeSaved(saved, &out); err != nil {
		return AuditLog{}, err
	}
	return out, nil
}

func (c AuditLogsClient) DeleteByID(ctx context.Context, id string) error {
	return c.core.Delete(ctx, Tables.AuditLog, id)
}

func (c AuditLogsMapClient) Where(cond onyx.Condition) AuditLogsMapClient { c.q = c.q.Where(cond); return c }
func (c AuditLogsMapClient) And(cond onyx.Condition) AuditLogsMapClient { c.q = c.q.And(cond); return c }
func (c AuditLogsMapClient) Or(cond onyx.Condition) AuditLogsMapClient { c.q = c.q.Or(cond); return c }
func (c AuditLogsMapClient) Resolve(resolvers ...string) AuditLogsMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c AuditLogsMapClient) OrderBy(field string, asc bool) AuditLogsMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c AuditLogsMapClient) Limit(n int) AuditLogsMapClient { c.q = c.q.Limit(n); return c }
func (c AuditLogsMapClient) SetUpdates(updates map[string]any) AuditLogsMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c AuditLogsMapClient) Select(fields ...string) AuditLogsMapClient { c.q = c.q.Select(fields...); return c }
func (c AuditLogsMapClient) GroupBy(fields ...string) AuditLogsMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c AuditLogsMapClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c AuditLogsMapClient) List(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c AuditLogsMapClient) Page(ctx context.Context, cursor string) (AuditLogMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return AuditLogMapPage{}, err
	}
	return AuditLogMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c AuditLogsMapClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c AuditLogsMapClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

type PermissionPage struct {
	Items []Permission `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type PermissionMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type PermissionsClient struct { core onyx.Client; q onyx.Query }
type PermissionsMapClient struct { core onyx.Client; q onyx.Query }

func (c DB) Permissions() PermissionsClient { return PermissionsClient{core: c.core, q: c.core.From(Tables.Permission)} }

func (c PermissionsClient) Where(cond onyx.Condition) PermissionsClient { c.q = c.q.Where(cond); return c }
func (c PermissionsClient) And(cond onyx.Condition) PermissionsClient { c.q = c.q.And(cond); return c }
func (c PermissionsClient) Or(cond onyx.Condition) PermissionsClient { c.q = c.q.Or(cond); return c }
func (c PermissionsClient) Resolve(resolvers ...string) PermissionsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c PermissionsClient) OrderBy(field string, asc bool) PermissionsClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c PermissionsClient) Limit(n int) PermissionsClient { c.q = c.q.Limit(n); return c }
func (c PermissionsClient) SetUpdates(updates map[string]any) PermissionsClient { c.q = c.q.SetUpdates(updates); return c }
func (c PermissionsClient) Select(fields ...string) PermissionsMapClient {
	c.q = c.q.Select(fields...)
	return PermissionsMapClient{core: c.core, q: c.q}
}
func (c PermissionsClient) GroupBy(fields ...string) PermissionsMapClient {
	c.q = c.q.GroupBy(fields...)
	return PermissionsMapClient{core: c.core, q: c.q}
}
func (c PermissionsClient) AsMaps() PermissionsMapClient { return PermissionsMapClient{core: c.core, q: c.q} }
func (c PermissionsClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c PermissionsClient) List(ctx context.Context) ([]Permission, error) {
	res := onyx.List(ctx, c.q)
	var out []Permission
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c PermissionsClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c PermissionsClient) Page(ctx context.Context, cursor string) (PermissionPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return PermissionPage{}, err
	}
	var items []Permission
	if err := decodeList(res.Items, &items); err != nil {
		return PermissionPage{}, err
	}
	return PermissionPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c PermissionsClient) PageOfMaps(ctx context.Context, cursor string) (PermissionMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return PermissionMapPage{}, err
	}
	return PermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c PermissionsClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c PermissionsClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

func (c PermissionsClient) Save(ctx context.Context, item Permission, cascades ...onyx.CascadeSpec) (Permission, error) {
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.Permission, item, relationships)
	if err != nil {
		return Permission{}, err
	}
	var out Permission
	if err := decodeSaved(saved, &out); err != nil {
		return Permission{}, err
	}
	return out, nil
}

func (c PermissionsClient) DeleteByID(ctx context.Context, id string) error {
	return c.core.Delete(ctx, Tables.Permission, id)
}

func (c PermissionsMapClient) Where(cond onyx.Condition) PermissionsMapClient { c.q = c.q.Where(cond); return c }
func (c PermissionsMapClient) And(cond onyx.Condition) PermissionsMapClient { c.q = c.q.And(cond); return c }
func (c PermissionsMapClient) Or(cond onyx.Condition) PermissionsMapClient { c.q = c.q.Or(cond); return c }
func (c PermissionsMapClient) Resolve(resolvers ...string) PermissionsMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c PermissionsMapClient) OrderBy(field string, asc bool) PermissionsMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c PermissionsMapClient) Limit(n int) PermissionsMapClient { c.q = c.q.Limit(n); return c }
func (c PermissionsMapClient) SetUpdates(updates map[string]any) PermissionsMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c PermissionsMapClient) Select(fields ...string) PermissionsMapClient { c.q = c.q.Select(fields...); return c }
func (c PermissionsMapClient) GroupBy(fields ...string) PermissionsMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c PermissionsMapClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c PermissionsMapClient) List(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c PermissionsMapClient) Page(ctx context.Context, cursor string) (PermissionMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return PermissionMapPage{}, err
	}
	return PermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c PermissionsMapClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c PermissionsMapClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

type RolePage struct {
	Items []Role `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RoleMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RolesClient struct { core onyx.Client; q onyx.Query }
type RolesMapClient struct { core onyx.Client; q onyx.Query }

func (c DB) Roles() RolesClient { return RolesClient{core: c.core, q: c.core.From(Tables.Role)} }

func (c RolesClient) Where(cond onyx.Condition) RolesClient { c.q = c.q.Where(cond); return c }
func (c RolesClient) And(cond onyx.Condition) RolesClient { c.q = c.q.And(cond); return c }
func (c RolesClient) Or(cond onyx.Condition) RolesClient { c.q = c.q.Or(cond); return c }
func (c RolesClient) Resolve(resolvers ...string) RolesClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolesClient) OrderBy(field string, asc bool) RolesClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolesClient) Limit(n int) RolesClient { c.q = c.q.Limit(n); return c }
func (c RolesClient) SetUpdates(updates map[string]any) RolesClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolesClient) Select(fields ...string) RolesMapClient {
	c.q = c.q.Select(fields...)
	return RolesMapClient{core: c.core, q: c.q}
}
func (c RolesClient) GroupBy(fields ...string) RolesMapClient {
	c.q = c.q.GroupBy(fields...)
	return RolesMapClient{core: c.core, q: c.q}
}
func (c RolesClient) AsMaps() RolesMapClient { return RolesMapClient{core: c.core, q: c.q} }
func (c RolesClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c RolesClient) List(ctx context.Context) ([]Role, error) {
	res := onyx.List(ctx, c.q)
	var out []Role
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolesClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolesClient) Page(ctx context.Context, cursor string) (RolePage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RolePage{}, err
	}
	var items []Role
	if err := decodeList(res.Items, &items); err != nil {
		return RolePage{}, err
	}
	return RolePage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c RolesClient) PageOfMaps(ctx context.Context, cursor string) (RoleMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RoleMapPage{}, err
	}
	return RoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolesClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c RolesClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

func (c RolesClient) Save(ctx context.Context, item Role, cascades ...onyx.CascadeSpec) (Role, error) {
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.Role, item, relationships)
	if err != nil {
		return Role{}, err
	}
	var out Role
	if err := decodeSaved(saved, &out); err != nil {
		return Role{}, err
	}
	return out, nil
}

func (c RolesClient) DeleteByID(ctx context.Context, id string) error {
	return c.core.Delete(ctx, Tables.Role, id)
}

func (c RolesMapClient) Where(cond onyx.Condition) RolesMapClient { c.q = c.q.Where(cond); return c }
func (c RolesMapClient) And(cond onyx.Condition) RolesMapClient { c.q = c.q.And(cond); return c }
func (c RolesMapClient) Or(cond onyx.Condition) RolesMapClient { c.q = c.q.Or(cond); return c }
func (c RolesMapClient) Resolve(resolvers ...string) RolesMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolesMapClient) OrderBy(field string, asc bool) RolesMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolesMapClient) Limit(n int) RolesMapClient { c.q = c.q.Limit(n); return c }
func (c RolesMapClient) SetUpdates(updates map[string]any) RolesMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolesMapClient) Select(fields ...string) RolesMapClient { c.q = c.q.Select(fields...); return c }
func (c RolesMapClient) GroupBy(fields ...string) RolesMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c RolesMapClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c RolesMapClient) List(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolesMapClient) Page(ctx context.Context, cursor string) (RoleMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RoleMapPage{}, err
	}
	return RoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolesMapClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c RolesMapClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

type RolePermissionPage struct {
	Items []RolePermission `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RolePermissionMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type RolePermissionsClient struct { core onyx.Client; q onyx.Query }
type RolePermissionsMapClient struct { core onyx.Client; q onyx.Query }

func (c DB) RolePermissions() RolePermissionsClient { return RolePermissionsClient{core: c.core, q: c.core.From(Tables.RolePermission)} }

func (c RolePermissionsClient) Where(cond onyx.Condition) RolePermissionsClient { c.q = c.q.Where(cond); return c }
func (c RolePermissionsClient) And(cond onyx.Condition) RolePermissionsClient { c.q = c.q.And(cond); return c }
func (c RolePermissionsClient) Or(cond onyx.Condition) RolePermissionsClient { c.q = c.q.Or(cond); return c }
func (c RolePermissionsClient) Resolve(resolvers ...string) RolePermissionsClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolePermissionsClient) OrderBy(field string, asc bool) RolePermissionsClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolePermissionsClient) Limit(n int) RolePermissionsClient { c.q = c.q.Limit(n); return c }
func (c RolePermissionsClient) SetUpdates(updates map[string]any) RolePermissionsClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolePermissionsClient) Select(fields ...string) RolePermissionsMapClient {
	c.q = c.q.Select(fields...)
	return RolePermissionsMapClient{core: c.core, q: c.q}
}
func (c RolePermissionsClient) GroupBy(fields ...string) RolePermissionsMapClient {
	c.q = c.q.GroupBy(fields...)
	return RolePermissionsMapClient{core: c.core, q: c.q}
}
func (c RolePermissionsClient) AsMaps() RolePermissionsMapClient { return RolePermissionsMapClient{core: c.core, q: c.q} }
func (c RolePermissionsClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c RolePermissionsClient) List(ctx context.Context) ([]RolePermission, error) {
	res := onyx.List(ctx, c.q)
	var out []RolePermission
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolePermissionsClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolePermissionsClient) Page(ctx context.Context, cursor string) (RolePermissionPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RolePermissionPage{}, err
	}
	var items []RolePermission
	if err := decodeList(res.Items, &items); err != nil {
		return RolePermissionPage{}, err
	}
	return RolePermissionPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c RolePermissionsClient) PageOfMaps(ctx context.Context, cursor string) (RolePermissionMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RolePermissionMapPage{}, err
	}
	return RolePermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolePermissionsClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c RolePermissionsClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

func (c RolePermissionsClient) Save(ctx context.Context, item RolePermission, cascades ...onyx.CascadeSpec) (RolePermission, error) {
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.RolePermission, item, relationships)
	if err != nil {
		return RolePermission{}, err
	}
	var out RolePermission
	if err := decodeSaved(saved, &out); err != nil {
		return RolePermission{}, err
	}
	return out, nil
}

func (c RolePermissionsClient) DeleteByID(ctx context.Context, id string) error {
	return c.core.Delete(ctx, Tables.RolePermission, id)
}

func (c RolePermissionsMapClient) Where(cond onyx.Condition) RolePermissionsMapClient { c.q = c.q.Where(cond); return c }
func (c RolePermissionsMapClient) And(cond onyx.Condition) RolePermissionsMapClient { c.q = c.q.And(cond); return c }
func (c RolePermissionsMapClient) Or(cond onyx.Condition) RolePermissionsMapClient { c.q = c.q.Or(cond); return c }
func (c RolePermissionsMapClient) Resolve(resolvers ...string) RolePermissionsMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c RolePermissionsMapClient) OrderBy(field string, asc bool) RolePermissionsMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c RolePermissionsMapClient) Limit(n int) RolePermissionsMapClient { c.q = c.q.Limit(n); return c }
func (c RolePermissionsMapClient) SetUpdates(updates map[string]any) RolePermissionsMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c RolePermissionsMapClient) Select(fields ...string) RolePermissionsMapClient { c.q = c.q.Select(fields...); return c }
func (c RolePermissionsMapClient) GroupBy(fields ...string) RolePermissionsMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c RolePermissionsMapClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c RolePermissionsMapClient) List(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c RolePermissionsMapClient) Page(ctx context.Context, cursor string) (RolePermissionMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return RolePermissionMapPage{}, err
	}
	return RolePermissionMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c RolePermissionsMapClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c RolePermissionsMapClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

type UserPage struct {
	Items []User `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UsersClient struct { core onyx.Client; q onyx.Query }
type UsersMapClient struct { core onyx.Client; q onyx.Query }

func (c DB) Users() UsersClient { return UsersClient{core: c.core, q: c.core.From(Tables.User)} }

func (c UsersClient) Where(cond onyx.Condition) UsersClient { c.q = c.q.Where(cond); return c }
func (c UsersClient) And(cond onyx.Condition) UsersClient { c.q = c.q.And(cond); return c }
func (c UsersClient) Or(cond onyx.Condition) UsersClient { c.q = c.q.Or(cond); return c }
func (c UsersClient) Resolve(resolvers ...string) UsersClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UsersClient) OrderBy(field string, asc bool) UsersClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UsersClient) Limit(n int) UsersClient { c.q = c.q.Limit(n); return c }
func (c UsersClient) SetUpdates(updates map[string]any) UsersClient { c.q = c.q.SetUpdates(updates); return c }
func (c UsersClient) Select(fields ...string) UsersMapClient {
	c.q = c.q.Select(fields...)
	return UsersMapClient{core: c.core, q: c.q}
}
func (c UsersClient) GroupBy(fields ...string) UsersMapClient {
	c.q = c.q.GroupBy(fields...)
	return UsersMapClient{core: c.core, q: c.q}
}
func (c UsersClient) AsMaps() UsersMapClient { return UsersMapClient{core: c.core, q: c.q} }
func (c UsersClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c UsersClient) List(ctx context.Context) ([]User, error) {
	res := onyx.List(ctx, c.q)
	var out []User
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UsersClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UsersClient) Page(ctx context.Context, cursor string) (UserPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserPage{}, err
	}
	var items []User
	if err := decodeList(res.Items, &items); err != nil {
		return UserPage{}, err
	}
	return UserPage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c UsersClient) PageOfMaps(ctx context.Context, cursor string) (UserMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserMapPage{}, err
	}
	return UserMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UsersClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c UsersClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

func (c UsersClient) Save(ctx context.Context, item User, cascades ...onyx.CascadeSpec) (User, error) {
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.User, item, relationships)
	if err != nil {
		return User{}, err
	}
	var out User
	if err := decodeSaved(saved, &out); err != nil {
		return User{}, err
	}
	return out, nil
}

func (c UsersClient) DeleteByID(ctx context.Context, id string) error {
	return c.core.Delete(ctx, Tables.User, id)
}

func (c UsersMapClient) Where(cond onyx.Condition) UsersMapClient { c.q = c.q.Where(cond); return c }
func (c UsersMapClient) And(cond onyx.Condition) UsersMapClient { c.q = c.q.And(cond); return c }
func (c UsersMapClient) Or(cond onyx.Condition) UsersMapClient { c.q = c.q.Or(cond); return c }
func (c UsersMapClient) Resolve(resolvers ...string) UsersMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UsersMapClient) OrderBy(field string, asc bool) UsersMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UsersMapClient) Limit(n int) UsersMapClient { c.q = c.q.Limit(n); return c }
func (c UsersMapClient) SetUpdates(updates map[string]any) UsersMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c UsersMapClient) Select(fields ...string) UsersMapClient { c.q = c.q.Select(fields...); return c }
func (c UsersMapClient) GroupBy(fields ...string) UsersMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c UsersMapClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c UsersMapClient) List(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UsersMapClient) Page(ctx context.Context, cursor string) (UserMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserMapPage{}, err
	}
	return UserMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UsersMapClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c UsersMapClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

type UserProfilePage struct {
	Items []UserProfile `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserProfileMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserProfilesClient struct { core onyx.Client; q onyx.Query }
type UserProfilesMapClient struct { core onyx.Client; q onyx.Query }

func (c DB) UserProfiles() UserProfilesClient { return UserProfilesClient{core: c.core, q: c.core.From(Tables.UserProfile)} }

func (c UserProfilesClient) Where(cond onyx.Condition) UserProfilesClient { c.q = c.q.Where(cond); return c }
func (c UserProfilesClient) And(cond onyx.Condition) UserProfilesClient { c.q = c.q.And(cond); return c }
func (c UserProfilesClient) Or(cond onyx.Condition) UserProfilesClient { c.q = c.q.Or(cond); return c }
func (c UserProfilesClient) Resolve(resolvers ...string) UserProfilesClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserProfilesClient) OrderBy(field string, asc bool) UserProfilesClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserProfilesClient) Limit(n int) UserProfilesClient { c.q = c.q.Limit(n); return c }
func (c UserProfilesClient) SetUpdates(updates map[string]any) UserProfilesClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserProfilesClient) Select(fields ...string) UserProfilesMapClient {
	c.q = c.q.Select(fields...)
	return UserProfilesMapClient{core: c.core, q: c.q}
}
func (c UserProfilesClient) GroupBy(fields ...string) UserProfilesMapClient {
	c.q = c.q.GroupBy(fields...)
	return UserProfilesMapClient{core: c.core, q: c.q}
}
func (c UserProfilesClient) AsMaps() UserProfilesMapClient { return UserProfilesMapClient{core: c.core, q: c.q} }
func (c UserProfilesClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c UserProfilesClient) List(ctx context.Context) ([]UserProfile, error) {
	res := onyx.List(ctx, c.q)
	var out []UserProfile
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserProfilesClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserProfilesClient) Page(ctx context.Context, cursor string) (UserProfilePage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserProfilePage{}, err
	}
	var items []UserProfile
	if err := decodeList(res.Items, &items); err != nil {
		return UserProfilePage{}, err
	}
	return UserProfilePage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c UserProfilesClient) PageOfMaps(ctx context.Context, cursor string) (UserProfileMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserProfileMapPage{}, err
	}
	return UserProfileMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserProfilesClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c UserProfilesClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

func (c UserProfilesClient) Save(ctx context.Context, item UserProfile, cascades ...onyx.CascadeSpec) (UserProfile, error) {
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.UserProfile, item, relationships)
	if err != nil {
		return UserProfile{}, err
	}
	var out UserProfile
	if err := decodeSaved(saved, &out); err != nil {
		return UserProfile{}, err
	}
	return out, nil
}

func (c UserProfilesClient) DeleteByID(ctx context.Context, id string) error {
	return c.core.Delete(ctx, Tables.UserProfile, id)
}

func (c UserProfilesMapClient) Where(cond onyx.Condition) UserProfilesMapClient { c.q = c.q.Where(cond); return c }
func (c UserProfilesMapClient) And(cond onyx.Condition) UserProfilesMapClient { c.q = c.q.And(cond); return c }
func (c UserProfilesMapClient) Or(cond onyx.Condition) UserProfilesMapClient { c.q = c.q.Or(cond); return c }
func (c UserProfilesMapClient) Resolve(resolvers ...string) UserProfilesMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserProfilesMapClient) OrderBy(field string, asc bool) UserProfilesMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserProfilesMapClient) Limit(n int) UserProfilesMapClient { c.q = c.q.Limit(n); return c }
func (c UserProfilesMapClient) SetUpdates(updates map[string]any) UserProfilesMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserProfilesMapClient) Select(fields ...string) UserProfilesMapClient { c.q = c.q.Select(fields...); return c }
func (c UserProfilesMapClient) GroupBy(fields ...string) UserProfilesMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c UserProfilesMapClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c UserProfilesMapClient) List(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserProfilesMapClient) Page(ctx context.Context, cursor string) (UserProfileMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserProfileMapPage{}, err
	}
	return UserProfileMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserProfilesMapClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c UserProfilesMapClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

type UserRolePage struct {
	Items []UserRole `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserRoleMapPage struct {
	Items []map[string]any `json:"items"`
	NextCursor string `json:"nextCursor,omitempty"`
}

type UserRolesClient struct { core onyx.Client; q onyx.Query }
type UserRolesMapClient struct { core onyx.Client; q onyx.Query }

func (c DB) UserRoles() UserRolesClient { return UserRolesClient{core: c.core, q: c.core.From(Tables.UserRole)} }

func (c UserRolesClient) Where(cond onyx.Condition) UserRolesClient { c.q = c.q.Where(cond); return c }
func (c UserRolesClient) And(cond onyx.Condition) UserRolesClient { c.q = c.q.And(cond); return c }
func (c UserRolesClient) Or(cond onyx.Condition) UserRolesClient { c.q = c.q.Or(cond); return c }
func (c UserRolesClient) Resolve(resolvers ...string) UserRolesClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserRolesClient) OrderBy(field string, asc bool) UserRolesClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserRolesClient) Limit(n int) UserRolesClient { c.q = c.q.Limit(n); return c }
func (c UserRolesClient) SetUpdates(updates map[string]any) UserRolesClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserRolesClient) Select(fields ...string) UserRolesMapClient {
	c.q = c.q.Select(fields...)
	return UserRolesMapClient{core: c.core, q: c.q}
}
func (c UserRolesClient) GroupBy(fields ...string) UserRolesMapClient {
	c.q = c.q.GroupBy(fields...)
	return UserRolesMapClient{core: c.core, q: c.q}
}
func (c UserRolesClient) AsMaps() UserRolesMapClient { return UserRolesMapClient{core: c.core, q: c.q} }
func (c UserRolesClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c UserRolesClient) List(ctx context.Context) ([]UserRole, error) {
	res := onyx.List(ctx, c.q)
	var out []UserRole
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserRolesClient) ListMaps(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserRolesClient) Page(ctx context.Context, cursor string) (UserRolePage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserRolePage{}, err
	}
	var items []UserRole
	if err := decodeList(res.Items, &items); err != nil {
		return UserRolePage{}, err
	}
	return UserRolePage{Items: items, NextCursor: res.NextCursor}, nil
}

func (c UserRolesClient) PageOfMaps(ctx context.Context, cursor string) (UserRoleMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserRoleMapPage{}, err
	}
	return UserRoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserRolesClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c UserRolesClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

func (c UserRolesClient) Save(ctx context.Context, item UserRole, cascades ...onyx.CascadeSpec) (UserRole, error) {
	relationships := make([]string, 0, len(cascades))
	for _, spec := range cascades {
		if spec != nil {
			relationships = append(relationships, spec.String())
		}
	}
	if len(relationships) == 0 {
		relationships = nil
	}
	saved, err := c.core.Save(ctx, Tables.UserRole, item, relationships)
	if err != nil {
		return UserRole{}, err
	}
	var out UserRole
	if err := decodeSaved(saved, &out); err != nil {
		return UserRole{}, err
	}
	return out, nil
}

func (c UserRolesClient) DeleteByID(ctx context.Context, id string) error {
	return c.core.Delete(ctx, Tables.UserRole, id)
}

func (c UserRolesMapClient) Where(cond onyx.Condition) UserRolesMapClient { c.q = c.q.Where(cond); return c }
func (c UserRolesMapClient) And(cond onyx.Condition) UserRolesMapClient { c.q = c.q.And(cond); return c }
func (c UserRolesMapClient) Or(cond onyx.Condition) UserRolesMapClient { c.q = c.q.Or(cond); return c }
func (c UserRolesMapClient) Resolve(resolvers ...string) UserRolesMapClient { c.q = c.q.Resolve(resolvers...); return c }
func (c UserRolesMapClient) OrderBy(field string, asc bool) UserRolesMapClient {
	if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }
	return c
}
func (c UserRolesMapClient) Limit(n int) UserRolesMapClient { c.q = c.q.Limit(n); return c }
func (c UserRolesMapClient) SetUpdates(updates map[string]any) UserRolesMapClient { c.q = c.q.SetUpdates(updates); return c }
func (c UserRolesMapClient) Select(fields ...string) UserRolesMapClient { c.q = c.q.Select(fields...); return c }
func (c UserRolesMapClient) GroupBy(fields ...string) UserRolesMapClient { c.q = c.q.GroupBy(fields...); return c }
func (c UserRolesMapClient) Stream(ctx context.Context) (onyx.Iterator, error) { return c.q.Stream(ctx) }
func (c UserRolesMapClient) List(ctx context.Context) ([]map[string]any, error) {
	res := onyx.List(ctx, c.q)
	var out []map[string]any
	if err := res.Decode(&out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c UserRolesMapClient) Page(ctx context.Context, cursor string) (UserRoleMapPage, error) {
	res, err := c.q.Page(ctx, cursor)
	if err != nil {
		return UserRoleMapPage{}, err
	}
	return UserRoleMapPage{Items: res.Items, NextCursor: res.NextCursor}, nil
}

func (c UserRolesMapClient) Update(ctx context.Context) (int, error) { return c.q.Update(ctx) }

func (c UserRolesMapClient) Delete(ctx context.Context) (int, error) { return c.q.Delete(ctx) }

func decodeSaved(saved map[string]any, out any) error {
	b, err := json.Marshal(saved)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, out)
}

func decodeList(items []map[string]any, out any) error {
	b, err := json.Marshal(items)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, out)
}

type DocumentsClient struct { core onyx.DocumentClient }

func (c DB) Documents() DocumentsClient { return DocumentsClient{core: c.core.Documents()} }

func (d DocumentsClient) List(ctx context.Context) ([]onyx.Document, error) { return d.core.List(ctx) }
func (d DocumentsClient) Get(ctx context.Context, id string) (onyx.Document, error) { return d.core.Get(ctx, id) }
func (d DocumentsClient) Save(ctx context.Context, doc onyx.Document) (onyx.Document, error) { return d.core.Save(ctx, doc) }
func (d DocumentsClient) Delete(ctx context.Context, id string) error { return d.core.Delete(ctx, id) }

type SecretsClient struct { core onyx.Client }

func (c DB) Secrets() SecretsClient { return SecretsClient{core: c.core} }

func (s SecretsClient) List(ctx context.Context) ([]onyx.Secret, error) { return s.core.ListSecrets(ctx) }
func (s SecretsClient) Get(ctx context.Context, key string) (onyx.Secret, error) { return s.core.GetSecret(ctx, key) }
func (s SecretsClient) Set(ctx context.Context, secret onyx.Secret) (onyx.Secret, error) { return s.core.PutSecret(ctx, secret) }
func (s SecretsClient) Delete(ctx context.Context, key string) error { return s.core.DeleteSecret(ctx, key) }

